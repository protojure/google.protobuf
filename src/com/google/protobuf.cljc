;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.google.protobuf
;;;----------------------------------------------------------------------------------
(ns com.google.protobuf
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :refer :all]
            [protojure.protobuf.serdes.complex :refer :all]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as stream]
            [com.google.protobuf :as com.google.protobuf]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->ListValue)
(declare ecis->ListValue)
(declare new-ListValue)
(declare cis->Empty)
(declare ecis->Empty)
(declare new-Empty)
(declare cis->Struct)
(declare ecis->Struct)
(declare new-Struct)
(declare cis->Api)
(declare ecis->Api)
(declare new-Api)
(declare cis->ServiceDescriptorProto)
(declare ecis->ServiceDescriptorProto)
(declare new-ServiceDescriptorProto)
(declare cis->Mixin)
(declare ecis->Mixin)
(declare new-Mixin)
(declare cis->FloatValue)
(declare ecis->FloatValue)
(declare new-FloatValue)
(declare cis->BoolValue)
(declare ecis->BoolValue)
(declare new-BoolValue)
(declare cis->DescriptorProto-ExtensionRange)
(declare ecis->DescriptorProto-ExtensionRange)
(declare new-DescriptorProto-ExtensionRange)
(declare cis->Type)
(declare ecis->Type)
(declare new-Type)
(declare cis->EnumValue)
(declare ecis->EnumValue)
(declare new-EnumValue)
(declare cis->Option)
(declare ecis->Option)
(declare new-Option)
(declare cis->Struct-FieldsEntry)
(declare ecis->Struct-FieldsEntry)
(declare new-Struct-FieldsEntry)
(declare cis->UninterpretedOption-NamePart)
(declare ecis->UninterpretedOption-NamePart)
(declare new-UninterpretedOption-NamePart)
(declare cis->FileDescriptorSet)
(declare ecis->FileDescriptorSet)
(declare new-FileDescriptorSet)
(declare cis->GeneratedCodeInfo-Annotation)
(declare ecis->GeneratedCodeInfo-Annotation)
(declare new-GeneratedCodeInfo-Annotation)
(declare cis->MethodOptions)
(declare ecis->MethodOptions)
(declare new-MethodOptions)
(declare cis->EnumDescriptorProto-EnumReservedRange)
(declare ecis->EnumDescriptorProto-EnumReservedRange)
(declare new-EnumDescriptorProto-EnumReservedRange)
(declare cis->EnumValueDescriptorProto)
(declare ecis->EnumValueDescriptorProto)
(declare new-EnumValueDescriptorProto)
(declare cis->UInt64Value)
(declare ecis->UInt64Value)
(declare new-UInt64Value)
(declare cis->SourceCodeInfo-Location)
(declare ecis->SourceCodeInfo-Location)
(declare new-SourceCodeInfo-Location)
(declare cis->FieldOptions)
(declare ecis->FieldOptions)
(declare new-FieldOptions)
(declare cis->EnumOptions)
(declare ecis->EnumOptions)
(declare new-EnumOptions)
(declare cis->MessageOptions)
(declare ecis->MessageOptions)
(declare new-MessageOptions)
(declare cis->BytesValue)
(declare ecis->BytesValue)
(declare new-BytesValue)
(declare cis->Any)
(declare ecis->Any)
(declare new-Any)
(declare cis->EnumDescriptorProto)
(declare ecis->EnumDescriptorProto)
(declare new-EnumDescriptorProto)
(declare cis->FieldMask)
(declare ecis->FieldMask)
(declare new-FieldMask)
(declare cis->UninterpretedOption)
(declare ecis->UninterpretedOption)
(declare new-UninterpretedOption)
(declare cis->ExtensionRangeOptions)
(declare ecis->ExtensionRangeOptions)
(declare new-ExtensionRangeOptions)
(declare cis->DoubleValue)
(declare ecis->DoubleValue)
(declare new-DoubleValue)
(declare cis->Value)
(declare ecis->Value)
(declare new-Value)
(declare cis->DescriptorProto)
(declare ecis->DescriptorProto)
(declare new-DescriptorProto)
(declare cis->Method)
(declare ecis->Method)
(declare new-Method)
(declare cis->OneofOptions)
(declare ecis->OneofOptions)
(declare new-OneofOptions)
(declare cis->SourceContext)
(declare ecis->SourceContext)
(declare new-SourceContext)
(declare cis->Duration)
(declare ecis->Duration)
(declare new-Duration)
(declare cis->MethodDescriptorProto)
(declare ecis->MethodDescriptorProto)
(declare new-MethodDescriptorProto)
(declare cis->OneofDescriptorProto)
(declare ecis->OneofDescriptorProto)
(declare new-OneofDescriptorProto)
(declare cis->FileDescriptorProto)
(declare ecis->FileDescriptorProto)
(declare new-FileDescriptorProto)
(declare cis->DescriptorProto-ReservedRange)
(declare ecis->DescriptorProto-ReservedRange)
(declare new-DescriptorProto-ReservedRange)
(declare cis->Int64Value)
(declare ecis->Int64Value)
(declare new-Int64Value)
(declare cis->EnumValueOptions)
(declare ecis->EnumValueOptions)
(declare new-EnumValueOptions)
(declare cis->UInt32Value)
(declare ecis->UInt32Value)
(declare new-UInt32Value)
(declare cis->Enum)
(declare ecis->Enum)
(declare new-Enum)
(declare cis->Timestamp)
(declare ecis->Timestamp)
(declare new-Timestamp)
(declare cis->FieldDescriptorProto)
(declare ecis->FieldDescriptorProto)
(declare new-FieldDescriptorProto)
(declare cis->GeneratedCodeInfo)
(declare ecis->GeneratedCodeInfo)
(declare new-GeneratedCodeInfo)
(declare cis->Field)
(declare ecis->Field)
(declare new-Field)
(declare cis->FileOptions)
(declare ecis->FileOptions)
(declare new-FileOptions)
(declare cis->SourceCodeInfo)
(declare ecis->SourceCodeInfo)
(declare new-SourceCodeInfo)
(declare cis->ServiceOptions)
(declare ecis->ServiceOptions)
(declare new-ServiceOptions)
(declare cis->Int32Value)
(declare ecis->Int32Value)
(declare new-Int32Value)
(declare cis->StringValue)
(declare ecis->StringValue)
(declare new-StringValue)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; FileOptions-OptimizeMode
;-----------------------------------------------------------------------------
(def FileOptions-OptimizeMode-val2label {
  1 :speed
  2 :code-size
  3 :lite-runtime})

(def FileOptions-OptimizeMode-label2val (set/map-invert FileOptions-OptimizeMode-val2label))

(defn cis->FileOptions-OptimizeMode [is]
  (let [val (cis->Enum is)]
    (get FileOptions-OptimizeMode-val2label val val)))

(defn- get-FileOptions-OptimizeMode [value]
  {:pre [(or (int? value) (contains? FileOptions-OptimizeMode-label2val value))]}
  (get FileOptions-OptimizeMode-label2val value value))

(defn write-FileOptions-OptimizeMode [tag options value os]
  (write-Enum tag options (get-FileOptions-OptimizeMode value) os))

;-----------------------------------------------------------------------------
; FieldDescriptorProto-Type
;-----------------------------------------------------------------------------
(def FieldDescriptorProto-Type-val2label {
  9 :type-string
  3 :type-int64
  4 :type-uint64
  8 :type-bool
  14 :type-enum
  17 :type-sint32
  15 :type-sfixed32
  7 :type-fixed32
  5 :type-int32
  18 :type-sint64
  12 :type-bytes
  13 :type-uint32
  6 :type-fixed64
  1 :type-double
  11 :type-message
  2 :type-float
  16 :type-sfixed64
  10 :type-group})

(def FieldDescriptorProto-Type-label2val (set/map-invert FieldDescriptorProto-Type-val2label))

(defn cis->FieldDescriptorProto-Type [is]
  (let [val (cis->Enum is)]
    (get FieldDescriptorProto-Type-val2label val val)))

(defn- get-FieldDescriptorProto-Type [value]
  {:pre [(or (int? value) (contains? FieldDescriptorProto-Type-label2val value))]}
  (get FieldDescriptorProto-Type-label2val value value))

(defn write-FieldDescriptorProto-Type [tag options value os]
  (write-Enum tag options (get-FieldDescriptorProto-Type value) os))

;-----------------------------------------------------------------------------
; Field-Kind
;-----------------------------------------------------------------------------
(def Field-Kind-val2label {
  9 :type-string
  3 :type-int64
  4 :type-uint64
  8 :type-bool
  14 :type-enum
  17 :type-sint32
  15 :type-sfixed32
  7 :type-fixed32
  5 :type-int32
  18 :type-sint64
  12 :type-bytes
  13 :type-uint32
  6 :type-fixed64
  1 :type-double
  0 :type-unknown
  11 :type-message
  2 :type-float
  16 :type-sfixed64
  10 :type-group})

(def Field-Kind-label2val (set/map-invert Field-Kind-val2label))

(defn cis->Field-Kind [is]
  (let [val (cis->Enum is)]
    (get Field-Kind-val2label val val)))

(defn- get-Field-Kind [value]
  {:pre [(or (int? value) (contains? Field-Kind-label2val value))]}
  (get Field-Kind-label2val value value))

(defn write-Field-Kind [tag options value os]
  (write-Enum tag options (get-Field-Kind value) os))

;-----------------------------------------------------------------------------
; NullValue
;-----------------------------------------------------------------------------
(def NullValue-val2label {
  0 :null-value})

(def NullValue-label2val (set/map-invert NullValue-val2label))

(defn cis->NullValue [is]
  (let [val (cis->Enum is)]
    (get NullValue-val2label val val)))

(defn- get-NullValue [value]
  {:pre [(or (int? value) (contains? NullValue-label2val value))]}
  (get NullValue-label2val value value))

(defn write-NullValue [tag options value os]
  (write-Enum tag options (get-NullValue value) os))

;-----------------------------------------------------------------------------
; Field-Cardinality
;-----------------------------------------------------------------------------
(def Field-Cardinality-val2label {
  0 :cardinality-unknown
  1 :cardinality-optional
  2 :cardinality-required
  3 :cardinality-repeated})

(def Field-Cardinality-label2val (set/map-invert Field-Cardinality-val2label))

(defn cis->Field-Cardinality [is]
  (let [val (cis->Enum is)]
    (get Field-Cardinality-val2label val val)))

(defn- get-Field-Cardinality [value]
  {:pre [(or (int? value) (contains? Field-Cardinality-label2val value))]}
  (get Field-Cardinality-label2val value value))

(defn write-Field-Cardinality [tag options value os]
  (write-Enum tag options (get-Field-Cardinality value) os))

;-----------------------------------------------------------------------------
; Syntax
;-----------------------------------------------------------------------------
(def Syntax-val2label {
  0 :syntax-proto2
  1 :syntax-proto3})

(def Syntax-label2val (set/map-invert Syntax-val2label))

(defn cis->Syntax [is]
  (let [val (cis->Enum is)]
    (get Syntax-val2label val val)))

(defn- get-Syntax [value]
  {:pre [(or (int? value) (contains? Syntax-label2val value))]}
  (get Syntax-label2val value value))

(defn write-Syntax [tag options value os]
  (write-Enum tag options (get-Syntax value) os))

;-----------------------------------------------------------------------------
; FieldOptions-JSType
;-----------------------------------------------------------------------------
(def FieldOptions-JSType-val2label {
  0 :js-normal
  1 :js-string
  2 :js-number})

(def FieldOptions-JSType-label2val (set/map-invert FieldOptions-JSType-val2label))

(defn cis->FieldOptions-JSType [is]
  (let [val (cis->Enum is)]
    (get FieldOptions-JSType-val2label val val)))

(defn- get-FieldOptions-JSType [value]
  {:pre [(or (int? value) (contains? FieldOptions-JSType-label2val value))]}
  (get FieldOptions-JSType-label2val value value))

(defn write-FieldOptions-JSType [tag options value os]
  (write-Enum tag options (get-FieldOptions-JSType value) os))

;-----------------------------------------------------------------------------
; FieldDescriptorProto-Label
;-----------------------------------------------------------------------------
(def FieldDescriptorProto-Label-val2label {
  1 :label-optional
  2 :label-required
  3 :label-repeated})

(def FieldDescriptorProto-Label-label2val (set/map-invert FieldDescriptorProto-Label-val2label))

(defn cis->FieldDescriptorProto-Label [is]
  (let [val (cis->Enum is)]
    (get FieldDescriptorProto-Label-val2label val val)))

(defn- get-FieldDescriptorProto-Label [value]
  {:pre [(or (int? value) (contains? FieldDescriptorProto-Label-label2val value))]}
  (get FieldDescriptorProto-Label-label2val value value))

(defn write-FieldDescriptorProto-Label [tag options value os]
  (write-Enum tag options (get-FieldDescriptorProto-Label value) os))

;-----------------------------------------------------------------------------
; FieldOptions-CType
;-----------------------------------------------------------------------------
(def FieldOptions-CType-val2label {
  0 :string
  1 :cord
  2 :string-piece})

(def FieldOptions-CType-label2val (set/map-invert FieldOptions-CType-val2label))

(defn cis->FieldOptions-CType [is]
  (let [val (cis->Enum is)]
    (get FieldOptions-CType-val2label val val)))

(defn- get-FieldOptions-CType [value]
  {:pre [(or (int? value) (contains? FieldOptions-CType-label2val value))]}
  (get FieldOptions-CType-label2val value value))

(defn write-FieldOptions-CType [tag options value os]
  (write-Enum tag options (get-FieldOptions-CType value) os))

;-----------------------------------------------------------------------------
; MethodOptions-IdempotencyLevel
;-----------------------------------------------------------------------------
(def MethodOptions-IdempotencyLevel-val2label {
  0 :idempotency-unknown
  1 :no-side-effects
  2 :idempotent})

(def MethodOptions-IdempotencyLevel-label2val (set/map-invert MethodOptions-IdempotencyLevel-val2label))

(defn cis->MethodOptions-IdempotencyLevel [is]
  (let [val (cis->Enum is)]
    (get MethodOptions-IdempotencyLevel-val2label val val)))

(defn- get-MethodOptions-IdempotencyLevel [value]
  {:pre [(or (int? value) (contains? MethodOptions-IdempotencyLevel-label2val value))]}
  (get MethodOptions-IdempotencyLevel-label2val value value))

(defn write-MethodOptions-IdempotencyLevel [tag options value os]
  (write-Enum tag options (get-MethodOptions-IdempotencyLevel value) os))


;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; kind's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-kind [origkeyval]
  (cond
     (get-in origkeyval [:kind :null-value]) origkeyval
     (get-in origkeyval [:kind :number-value]) origkeyval
     (get-in origkeyval [:kind :string-value]) origkeyval
     (get-in origkeyval [:kind :bool-value]) origkeyval
     (get-in origkeyval [:kind :struct-value]) (update-in origkeyval [:kind :struct-value] new-Struct)
     (get-in origkeyval [:kind :list-value]) (update-in origkeyval [:kind :list-value] new-ListValue)
     :default origkeyval))

(defn write-kind [kind os]
  (let [field (first kind)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :null-value (write-NullValue 1  {:optimize false} v os)
         :number-value (write-Double 2  {:optimize false} v os)
         :string-value (write-String 3  {:optimize false} v os)
         :bool-value (write-Bool 4  {:optimize false} v os)
         :struct-value (write-embedded 5 v os)
         :list-value (write-embedded 6 v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; ListValue
;-----------------------------------------------------------------------------
(defrecord ListValue [values]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 1 (:values this) os)))

(s/def ::ListValue-spec (s/keys :opt-un []))
(def ListValue-defaults {:values [] })

(defn cis->ListValue
  "CodedInputStream to ListValue"
  [is]
  (->> (tag-map ListValue-defaults
         (fn [tag index]
             (case index
               1 [:values (cis->repeated ecis->Value is)]

               [index (cis->undefined tag is)]))
         is)
        (map->ListValue)))

(defn ecis->ListValue
  "Embedded CodedInputStream to ListValue"
  [is]
  (cis->embedded cis->ListValue is))

(defn new-ListValue
  "Creates a new instance from a map, similar to map->ListValue except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ListValue-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ListValue-spec init))))]}
  (-> (merge ListValue-defaults init)
      (cond-> (contains? init :values) (update :values #(map new-Value %)))
      (map->ListValue)))

(defn pb->ListValue
  "Protobuf to ListValue"
  [input]
  (cis->ListValue (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Empty
;-----------------------------------------------------------------------------
(defrecord Empty []
  pb/Writer

  (serialize [this os]
))

(s/def ::Empty-spec (s/keys :opt-un []))
(def Empty-defaults {})

(defn cis->Empty
  "CodedInputStream to Empty"
  [is]
  (->> (tag-map Empty-defaults
         (fn [tag index]
             (case index
               [index (cis->undefined tag is)]))
         is)
        (map->Empty)))

(defn ecis->Empty
  "Embedded CodedInputStream to Empty"
  [is]
  (cis->embedded cis->Empty is))

(defn new-Empty
  "Creates a new instance from a map, similar to map->Empty except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Empty-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Empty-spec init))))]}
  (-> (merge Empty-defaults init)
      (map->Empty)))

(defn pb->Empty
  "Protobuf to Empty"
  [input]
  (cis->Empty (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Struct
;-----------------------------------------------------------------------------
(defrecord Struct [fields]
  pb/Writer

  (serialize [this os]
    (write-map new-Struct-FieldsEntry 1 (:fields this) os)))

(s/def ::Struct-spec (s/keys :opt-un []))
(def Struct-defaults {:fields [] })

(defn cis->Struct
  "CodedInputStream to Struct"
  [is]
  (->> (tag-map Struct-defaults
         (fn [tag index]
             (case index
               1 [:fields (cis->map ecis->Struct-FieldsEntry is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Struct)))

(defn ecis->Struct
  "Embedded CodedInputStream to Struct"
  [is]
  (cis->embedded cis->Struct is))

(defn new-Struct
  "Creates a new instance from a map, similar to map->Struct except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Struct-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Struct-spec init))))]}
  (-> (merge Struct-defaults init)
      (map->Struct)))

(defn pb->Struct
  "Protobuf to Struct"
  [input]
  (cis->Struct (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Api
;-----------------------------------------------------------------------------
(defrecord Api [name methods options version source-context mixins syntax]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-repeated write-embedded 2 (:methods this) os)
    (write-repeated write-embedded 3 (:options this) os)
    (write-String 4  {:optimize true} (:version this) os)
    (write-embedded 5 (:source-context this) os)
    (write-repeated write-embedded 6 (:mixins this) os)
    (write-Syntax 7  {:optimize true} (:syntax this) os)))

(s/def :com.google.protobuf.Api/name string?)


(s/def :com.google.protobuf.Api/version string?)


(s/def :com.google.protobuf.Api/syntax (s/or :keyword keyword? :int int?))
(s/def ::Api-spec (s/keys :opt-un [:com.google.protobuf.Api/name :com.google.protobuf.Api/version :com.google.protobuf.Api/syntax ]))
(def Api-defaults {:name "" :methods [] :options [] :version "" :mixins [] :syntax (Syntax-val2label 0) })

(defn cis->Api
  "CodedInputStream to Api"
  [is]
  (->> (tag-map Api-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:methods (cis->repeated ecis->Method is)]
               3 [:options (cis->repeated ecis->Option is)]
               4 [:version (cis->String is)]
               5 [:source-context (ecis->SourceContext is)]
               6 [:mixins (cis->repeated ecis->Mixin is)]
               7 [:syntax (cis->Syntax is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Api)))

(defn ecis->Api
  "Embedded CodedInputStream to Api"
  [is]
  (cis->embedded cis->Api is))

(defn new-Api
  "Creates a new instance from a map, similar to map->Api except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Api-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Api-spec init))))]}
  (-> (merge Api-defaults init)
      (cond-> (contains? init :methods) (update :methods #(map new-Method %)))
      (cond-> (contains? init :options) (update :options #(map new-Option %)))
      (cond-> (contains? init :source-context) (update :source-context new-SourceContext))
      (cond-> (contains? init :mixins) (update :mixins #(map new-Mixin %)))
      (map->Api)))

(defn pb->Api
  "Protobuf to Api"
  [input]
  (cis->Api (stream/new-cis input)))

;-----------------------------------------------------------------------------
; ServiceDescriptorProto
;-----------------------------------------------------------------------------
(defrecord ServiceDescriptorProto [name method options]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-repeated write-embedded 2 (:method this) os)
    (write-embedded 3 (:options this) os)))

(s/def :com.google.protobuf.ServiceDescriptorProto/name string?)


(s/def ::ServiceDescriptorProto-spec (s/keys :opt-un [:com.google.protobuf.ServiceDescriptorProto/name ]))
(def ServiceDescriptorProto-defaults {:name "" :method [] })

(defn cis->ServiceDescriptorProto
  "CodedInputStream to ServiceDescriptorProto"
  [is]
  (->> (tag-map ServiceDescriptorProto-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:method (cis->repeated ecis->MethodDescriptorProto is)]
               3 [:options (ecis->ServiceOptions is)]

               [index (cis->undefined tag is)]))
         is)
        (map->ServiceDescriptorProto)))

(defn ecis->ServiceDescriptorProto
  "Embedded CodedInputStream to ServiceDescriptorProto"
  [is]
  (cis->embedded cis->ServiceDescriptorProto is))

(defn new-ServiceDescriptorProto
  "Creates a new instance from a map, similar to map->ServiceDescriptorProto except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ServiceDescriptorProto-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ServiceDescriptorProto-spec init))))]}
  (-> (merge ServiceDescriptorProto-defaults init)
      (cond-> (contains? init :method) (update :method #(map new-MethodDescriptorProto %)))
      (cond-> (contains? init :options) (update :options new-ServiceOptions))
      (map->ServiceDescriptorProto)))

(defn pb->ServiceDescriptorProto
  "Protobuf to ServiceDescriptorProto"
  [input]
  (cis->ServiceDescriptorProto (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Mixin
;-----------------------------------------------------------------------------
(defrecord Mixin [name root]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-String 2  {:optimize true} (:root this) os)))

(s/def :com.google.protobuf.Mixin/name string?)
(s/def :com.google.protobuf.Mixin/root string?)
(s/def ::Mixin-spec (s/keys :opt-un [:com.google.protobuf.Mixin/name :com.google.protobuf.Mixin/root ]))
(def Mixin-defaults {:name "" :root "" })

(defn cis->Mixin
  "CodedInputStream to Mixin"
  [is]
  (->> (tag-map Mixin-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:root (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Mixin)))

(defn ecis->Mixin
  "Embedded CodedInputStream to Mixin"
  [is]
  (cis->embedded cis->Mixin is))

(defn new-Mixin
  "Creates a new instance from a map, similar to map->Mixin except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Mixin-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Mixin-spec init))))]}
  (-> (merge Mixin-defaults init)
      (map->Mixin)))

(defn pb->Mixin
  "Protobuf to Mixin"
  [input]
  (cis->Mixin (stream/new-cis input)))

;-----------------------------------------------------------------------------
; FloatValue
;-----------------------------------------------------------------------------
(defrecord FloatValue [value]
  pb/Writer

  (serialize [this os]
    (write-Float 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.FloatValue/value float?)
(s/def ::FloatValue-spec (s/keys :opt-un [:com.google.protobuf.FloatValue/value ]))
(def FloatValue-defaults {:value 0.0 })

(defn cis->FloatValue
  "CodedInputStream to FloatValue"
  [is]
  (->> (tag-map FloatValue-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->Float is)]

               [index (cis->undefined tag is)]))
         is)
        (map->FloatValue)))

(defn ecis->FloatValue
  "Embedded CodedInputStream to FloatValue"
  [is]
  (cis->embedded cis->FloatValue is))

(defn new-FloatValue
  "Creates a new instance from a map, similar to map->FloatValue except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FloatValue-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FloatValue-spec init))))]}
  (-> (merge FloatValue-defaults init)
      (map->FloatValue)))

(defn pb->FloatValue
  "Protobuf to FloatValue"
  [input]
  (cis->FloatValue (stream/new-cis input)))

;-----------------------------------------------------------------------------
; BoolValue
;-----------------------------------------------------------------------------
(defrecord BoolValue [value]
  pb/Writer

  (serialize [this os]
    (write-Bool 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.BoolValue/value boolean?)
(s/def ::BoolValue-spec (s/keys :opt-un [:com.google.protobuf.BoolValue/value ]))
(def BoolValue-defaults {:value false })

(defn cis->BoolValue
  "CodedInputStream to BoolValue"
  [is]
  (->> (tag-map BoolValue-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->Bool is)]

               [index (cis->undefined tag is)]))
         is)
        (map->BoolValue)))

(defn ecis->BoolValue
  "Embedded CodedInputStream to BoolValue"
  [is]
  (cis->embedded cis->BoolValue is))

(defn new-BoolValue
  "Creates a new instance from a map, similar to map->BoolValue except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BoolValue-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BoolValue-spec init))))]}
  (-> (merge BoolValue-defaults init)
      (map->BoolValue)))

(defn pb->BoolValue
  "Protobuf to BoolValue"
  [input]
  (cis->BoolValue (stream/new-cis input)))

;-----------------------------------------------------------------------------
; DescriptorProto-ExtensionRange
;-----------------------------------------------------------------------------
(defrecord DescriptorProto-ExtensionRange [start end options]
  pb/Writer

  (serialize [this os]
    (write-Int32 1  {:optimize true} (:start this) os)
    (write-Int32 2  {:optimize true} (:end this) os)
    (write-embedded 3 (:options this) os)))

(s/def :com.google.protobuf.DescriptorProto-ExtensionRange/start int?)
(s/def :com.google.protobuf.DescriptorProto-ExtensionRange/end int?)

(s/def ::DescriptorProto-ExtensionRange-spec (s/keys :opt-un [:com.google.protobuf.DescriptorProto-ExtensionRange/start :com.google.protobuf.DescriptorProto-ExtensionRange/end ]))
(def DescriptorProto-ExtensionRange-defaults {:start 0 :end 0 })

(defn cis->DescriptorProto-ExtensionRange
  "CodedInputStream to DescriptorProto-ExtensionRange"
  [is]
  (->> (tag-map DescriptorProto-ExtensionRange-defaults
         (fn [tag index]
             (case index
               1 [:start (cis->Int32 is)]
               2 [:end (cis->Int32 is)]
               3 [:options (ecis->ExtensionRangeOptions is)]

               [index (cis->undefined tag is)]))
         is)
        (map->DescriptorProto-ExtensionRange)))

(defn ecis->DescriptorProto-ExtensionRange
  "Embedded CodedInputStream to DescriptorProto-ExtensionRange"
  [is]
  (cis->embedded cis->DescriptorProto-ExtensionRange is))

(defn new-DescriptorProto-ExtensionRange
  "Creates a new instance from a map, similar to map->DescriptorProto-ExtensionRange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DescriptorProto-ExtensionRange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DescriptorProto-ExtensionRange-spec init))))]}
  (-> (merge DescriptorProto-ExtensionRange-defaults init)
      (cond-> (contains? init :options) (update :options new-ExtensionRangeOptions))
      (map->DescriptorProto-ExtensionRange)))

(defn pb->DescriptorProto-ExtensionRange
  "Protobuf to DescriptorProto-ExtensionRange"
  [input]
  (cis->DescriptorProto-ExtensionRange (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Type
;-----------------------------------------------------------------------------
(defrecord Type [name fields oneofs options source-context syntax]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-repeated write-embedded 2 (:fields this) os)
    (write-repeated write-String 3 (:oneofs this) os)
    (write-repeated write-embedded 4 (:options this) os)
    (write-embedded 5 (:source-context this) os)
    (write-Syntax 6  {:optimize true} (:syntax this) os)))

(s/def :com.google.protobuf.Type/name string?)

(s/def :com.google.protobuf.Type/oneofs (s/every string?))


(s/def :com.google.protobuf.Type/syntax (s/or :keyword keyword? :int int?))
(s/def ::Type-spec (s/keys :opt-un [:com.google.protobuf.Type/name :com.google.protobuf.Type/oneofs :com.google.protobuf.Type/syntax ]))
(def Type-defaults {:name "" :fields [] :oneofs [] :options [] :syntax (Syntax-val2label 0) })

(defn cis->Type
  "CodedInputStream to Type"
  [is]
  (->> (tag-map Type-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:fields (cis->repeated ecis->Field is)]
               3 [:oneofs (cis->repeated cis->String is)]
               4 [:options (cis->repeated ecis->Option is)]
               5 [:source-context (ecis->SourceContext is)]
               6 [:syntax (cis->Syntax is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Type)))

(defn ecis->Type
  "Embedded CodedInputStream to Type"
  [is]
  (cis->embedded cis->Type is))

(defn new-Type
  "Creates a new instance from a map, similar to map->Type except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Type-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Type-spec init))))]}
  (-> (merge Type-defaults init)
      (cond-> (contains? init :fields) (update :fields #(map new-Field %)))
      (cond-> (contains? init :options) (update :options #(map new-Option %)))
      (cond-> (contains? init :source-context) (update :source-context new-SourceContext))
      (map->Type)))

(defn pb->Type
  "Protobuf to Type"
  [input]
  (cis->Type (stream/new-cis input)))

;-----------------------------------------------------------------------------
; EnumValue
;-----------------------------------------------------------------------------
(defrecord EnumValue [name number options]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-Int32 2  {:optimize true} (:number this) os)
    (write-repeated write-embedded 3 (:options this) os)))

(s/def :com.google.protobuf.EnumValue/name string?)
(s/def :com.google.protobuf.EnumValue/number int?)

(s/def ::EnumValue-spec (s/keys :opt-un [:com.google.protobuf.EnumValue/name :com.google.protobuf.EnumValue/number ]))
(def EnumValue-defaults {:name "" :number 0 :options [] })

(defn cis->EnumValue
  "CodedInputStream to EnumValue"
  [is]
  (->> (tag-map EnumValue-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:number (cis->Int32 is)]
               3 [:options (cis->repeated ecis->Option is)]

               [index (cis->undefined tag is)]))
         is)
        (map->EnumValue)))

(defn ecis->EnumValue
  "Embedded CodedInputStream to EnumValue"
  [is]
  (cis->embedded cis->EnumValue is))

(defn new-EnumValue
  "Creates a new instance from a map, similar to map->EnumValue except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EnumValue-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EnumValue-spec init))))]}
  (-> (merge EnumValue-defaults init)
      (cond-> (contains? init :options) (update :options #(map new-Option %)))
      (map->EnumValue)))

(defn pb->EnumValue
  "Protobuf to EnumValue"
  [input]
  (cis->EnumValue (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Option
;-----------------------------------------------------------------------------
(defrecord Option [name value]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-embedded 2 (:value this) os)))

(s/def :com.google.protobuf.Option/name string?)

(s/def ::Option-spec (s/keys :opt-un [:com.google.protobuf.Option/name ]))
(def Option-defaults {:name "" })

(defn cis->Option
  "CodedInputStream to Option"
  [is]
  (->> (tag-map Option-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:value (ecis->Any is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Option)))

(defn ecis->Option
  "Embedded CodedInputStream to Option"
  [is]
  (cis->embedded cis->Option is))

(defn new-Option
  "Creates a new instance from a map, similar to map->Option except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Option-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Option-spec init))))]}
  (-> (merge Option-defaults init)
      (cond-> (contains? init :value) (update :value new-Any))
      (map->Option)))

(defn pb->Option
  "Protobuf to Option"
  [input]
  (cis->Option (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Struct-FieldsEntry
;-----------------------------------------------------------------------------
(defrecord Struct-FieldsEntry [key value]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:key this) os)
    (write-embedded 2 (:value this) os)))

(s/def :com.google.protobuf.Struct-FieldsEntry/key string?)

(s/def ::Struct-FieldsEntry-spec (s/keys :opt-un [:com.google.protobuf.Struct-FieldsEntry/key ]))
(def Struct-FieldsEntry-defaults {:key "" })

(defn cis->Struct-FieldsEntry
  "CodedInputStream to Struct-FieldsEntry"
  [is]
  (->> (tag-map Struct-FieldsEntry-defaults
         (fn [tag index]
             (case index
               1 [:key (cis->String is)]
               2 [:value (ecis->Value is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Struct-FieldsEntry)))

(defn ecis->Struct-FieldsEntry
  "Embedded CodedInputStream to Struct-FieldsEntry"
  [is]
  (cis->embedded cis->Struct-FieldsEntry is))

(defn new-Struct-FieldsEntry
  "Creates a new instance from a map, similar to map->Struct-FieldsEntry except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Struct-FieldsEntry-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Struct-FieldsEntry-spec init))))]}
  (-> (merge Struct-FieldsEntry-defaults init)
      (cond-> (contains? init :value) (update :value new-Value))
      (map->Struct-FieldsEntry)))

(defn pb->Struct-FieldsEntry
  "Protobuf to Struct-FieldsEntry"
  [input]
  (cis->Struct-FieldsEntry (stream/new-cis input)))

;-----------------------------------------------------------------------------
; UninterpretedOption-NamePart
;-----------------------------------------------------------------------------
(defrecord UninterpretedOption-NamePart [name-part is-extension]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name-part this) os)
    (write-Bool 2  {:optimize true} (:is-extension this) os)))

(s/def :com.google.protobuf.UninterpretedOption-NamePart/name-part string?)
(s/def :com.google.protobuf.UninterpretedOption-NamePart/is-extension boolean?)
(s/def ::UninterpretedOption-NamePart-spec (s/keys :opt-un [:com.google.protobuf.UninterpretedOption-NamePart/name-part :com.google.protobuf.UninterpretedOption-NamePart/is-extension ]))
(def UninterpretedOption-NamePart-defaults {:name-part "" :is-extension false })

(defn cis->UninterpretedOption-NamePart
  "CodedInputStream to UninterpretedOption-NamePart"
  [is]
  (->> (tag-map UninterpretedOption-NamePart-defaults
         (fn [tag index]
             (case index
               1 [:name-part (cis->String is)]
               2 [:is-extension (cis->Bool is)]

               [index (cis->undefined tag is)]))
         is)
        (map->UninterpretedOption-NamePart)))

(defn ecis->UninterpretedOption-NamePart
  "Embedded CodedInputStream to UninterpretedOption-NamePart"
  [is]
  (cis->embedded cis->UninterpretedOption-NamePart is))

(defn new-UninterpretedOption-NamePart
  "Creates a new instance from a map, similar to map->UninterpretedOption-NamePart except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::UninterpretedOption-NamePart-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::UninterpretedOption-NamePart-spec init))))]}
  (-> (merge UninterpretedOption-NamePart-defaults init)
      (map->UninterpretedOption-NamePart)))

(defn pb->UninterpretedOption-NamePart
  "Protobuf to UninterpretedOption-NamePart"
  [input]
  (cis->UninterpretedOption-NamePart (stream/new-cis input)))

;-----------------------------------------------------------------------------
; FileDescriptorSet
;-----------------------------------------------------------------------------
(defrecord FileDescriptorSet [file]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 1 (:file this) os)))

(s/def ::FileDescriptorSet-spec (s/keys :opt-un []))
(def FileDescriptorSet-defaults {:file [] })

(defn cis->FileDescriptorSet
  "CodedInputStream to FileDescriptorSet"
  [is]
  (->> (tag-map FileDescriptorSet-defaults
         (fn [tag index]
             (case index
               1 [:file (cis->repeated ecis->FileDescriptorProto is)]

               [index (cis->undefined tag is)]))
         is)
        (map->FileDescriptorSet)))

(defn ecis->FileDescriptorSet
  "Embedded CodedInputStream to FileDescriptorSet"
  [is]
  (cis->embedded cis->FileDescriptorSet is))

(defn new-FileDescriptorSet
  "Creates a new instance from a map, similar to map->FileDescriptorSet except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FileDescriptorSet-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FileDescriptorSet-spec init))))]}
  (-> (merge FileDescriptorSet-defaults init)
      (cond-> (contains? init :file) (update :file #(map new-FileDescriptorProto %)))
      (map->FileDescriptorSet)))

(defn pb->FileDescriptorSet
  "Protobuf to FileDescriptorSet"
  [input]
  (cis->FileDescriptorSet (stream/new-cis input)))

;-----------------------------------------------------------------------------
; GeneratedCodeInfo-Annotation
;-----------------------------------------------------------------------------
(defrecord GeneratedCodeInfo-Annotation [path source-file begin end]
  pb/Writer

  (serialize [this os]
    (write-repeated write-Int32 1 (:path this) os)
    (write-String 2  {:optimize true} (:source-file this) os)
    (write-Int32 3  {:optimize true} (:begin this) os)
    (write-Int32 4  {:optimize true} (:end this) os)))

(s/def :com.google.protobuf.GeneratedCodeInfo-Annotation/path (s/every int?))
(s/def :com.google.protobuf.GeneratedCodeInfo-Annotation/source-file string?)
(s/def :com.google.protobuf.GeneratedCodeInfo-Annotation/begin int?)
(s/def :com.google.protobuf.GeneratedCodeInfo-Annotation/end int?)
(s/def ::GeneratedCodeInfo-Annotation-spec (s/keys :opt-un [:com.google.protobuf.GeneratedCodeInfo-Annotation/path :com.google.protobuf.GeneratedCodeInfo-Annotation/source-file :com.google.protobuf.GeneratedCodeInfo-Annotation/begin :com.google.protobuf.GeneratedCodeInfo-Annotation/end ]))
(def GeneratedCodeInfo-Annotation-defaults {:path [] :source-file "" :begin 0 :end 0 })

(defn cis->GeneratedCodeInfo-Annotation
  "CodedInputStream to GeneratedCodeInfo-Annotation"
  [is]
  (->> (tag-map GeneratedCodeInfo-Annotation-defaults
         (fn [tag index]
             (case index
               1 [:path (cis->packablerepeated tag cis->Int32 is)]
               2 [:source-file (cis->String is)]
               3 [:begin (cis->Int32 is)]
               4 [:end (cis->Int32 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->GeneratedCodeInfo-Annotation)))

(defn ecis->GeneratedCodeInfo-Annotation
  "Embedded CodedInputStream to GeneratedCodeInfo-Annotation"
  [is]
  (cis->embedded cis->GeneratedCodeInfo-Annotation is))

(defn new-GeneratedCodeInfo-Annotation
  "Creates a new instance from a map, similar to map->GeneratedCodeInfo-Annotation except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GeneratedCodeInfo-Annotation-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GeneratedCodeInfo-Annotation-spec init))))]}
  (-> (merge GeneratedCodeInfo-Annotation-defaults init)
      (map->GeneratedCodeInfo-Annotation)))

(defn pb->GeneratedCodeInfo-Annotation
  "Protobuf to GeneratedCodeInfo-Annotation"
  [input]
  (cis->GeneratedCodeInfo-Annotation (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MethodOptions
;-----------------------------------------------------------------------------
(defrecord MethodOptions [deprecated idempotency-level uninterpreted-option]
  pb/Writer

  (serialize [this os]
    (write-Bool 33  {:optimize true} (:deprecated this) os)
    (write-MethodOptions-IdempotencyLevel 34  {:optimize true} (:idempotency-level this) os)
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)))

(s/def :com.google.protobuf.MethodOptions/deprecated boolean?)
(s/def :com.google.protobuf.MethodOptions/idempotency-level (s/or :keyword keyword? :int int?))

(s/def ::MethodOptions-spec (s/keys :opt-un [:com.google.protobuf.MethodOptions/deprecated :com.google.protobuf.MethodOptions/idempotency-level ]))
(def MethodOptions-defaults {:deprecated false :idempotency-level (MethodOptions-IdempotencyLevel-val2label 0) :uninterpreted-option [] })

(defn cis->MethodOptions
  "CodedInputStream to MethodOptions"
  [is]
  (->> (tag-map MethodOptions-defaults
         (fn [tag index]
             (case index
               33 [:deprecated (cis->Bool is)]
               34 [:idempotency-level (cis->MethodOptions-IdempotencyLevel is)]
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MethodOptions)))

(defn ecis->MethodOptions
  "Embedded CodedInputStream to MethodOptions"
  [is]
  (cis->embedded cis->MethodOptions is))

(defn new-MethodOptions
  "Creates a new instance from a map, similar to map->MethodOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MethodOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MethodOptions-spec init))))]}
  (-> (merge MethodOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->MethodOptions)))

(defn pb->MethodOptions
  "Protobuf to MethodOptions"
  [input]
  (cis->MethodOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; EnumDescriptorProto-EnumReservedRange
;-----------------------------------------------------------------------------
(defrecord EnumDescriptorProto-EnumReservedRange [start end]
  pb/Writer

  (serialize [this os]
    (write-Int32 1  {:optimize true} (:start this) os)
    (write-Int32 2  {:optimize true} (:end this) os)))

(s/def :com.google.protobuf.EnumDescriptorProto-EnumReservedRange/start int?)
(s/def :com.google.protobuf.EnumDescriptorProto-EnumReservedRange/end int?)
(s/def ::EnumDescriptorProto-EnumReservedRange-spec (s/keys :opt-un [:com.google.protobuf.EnumDescriptorProto-EnumReservedRange/start :com.google.protobuf.EnumDescriptorProto-EnumReservedRange/end ]))
(def EnumDescriptorProto-EnumReservedRange-defaults {:start 0 :end 0 })

(defn cis->EnumDescriptorProto-EnumReservedRange
  "CodedInputStream to EnumDescriptorProto-EnumReservedRange"
  [is]
  (->> (tag-map EnumDescriptorProto-EnumReservedRange-defaults
         (fn [tag index]
             (case index
               1 [:start (cis->Int32 is)]
               2 [:end (cis->Int32 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->EnumDescriptorProto-EnumReservedRange)))

(defn ecis->EnumDescriptorProto-EnumReservedRange
  "Embedded CodedInputStream to EnumDescriptorProto-EnumReservedRange"
  [is]
  (cis->embedded cis->EnumDescriptorProto-EnumReservedRange is))

(defn new-EnumDescriptorProto-EnumReservedRange
  "Creates a new instance from a map, similar to map->EnumDescriptorProto-EnumReservedRange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EnumDescriptorProto-EnumReservedRange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EnumDescriptorProto-EnumReservedRange-spec init))))]}
  (-> (merge EnumDescriptorProto-EnumReservedRange-defaults init)
      (map->EnumDescriptorProto-EnumReservedRange)))

(defn pb->EnumDescriptorProto-EnumReservedRange
  "Protobuf to EnumDescriptorProto-EnumReservedRange"
  [input]
  (cis->EnumDescriptorProto-EnumReservedRange (stream/new-cis input)))

;-----------------------------------------------------------------------------
; EnumValueDescriptorProto
;-----------------------------------------------------------------------------
(defrecord EnumValueDescriptorProto [name number options]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-Int32 2  {:optimize true} (:number this) os)
    (write-embedded 3 (:options this) os)))

(s/def :com.google.protobuf.EnumValueDescriptorProto/name string?)
(s/def :com.google.protobuf.EnumValueDescriptorProto/number int?)

(s/def ::EnumValueDescriptorProto-spec (s/keys :opt-un [:com.google.protobuf.EnumValueDescriptorProto/name :com.google.protobuf.EnumValueDescriptorProto/number ]))
(def EnumValueDescriptorProto-defaults {:name "" :number 0 })

(defn cis->EnumValueDescriptorProto
  "CodedInputStream to EnumValueDescriptorProto"
  [is]
  (->> (tag-map EnumValueDescriptorProto-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:number (cis->Int32 is)]
               3 [:options (ecis->EnumValueOptions is)]

               [index (cis->undefined tag is)]))
         is)
        (map->EnumValueDescriptorProto)))

(defn ecis->EnumValueDescriptorProto
  "Embedded CodedInputStream to EnumValueDescriptorProto"
  [is]
  (cis->embedded cis->EnumValueDescriptorProto is))

(defn new-EnumValueDescriptorProto
  "Creates a new instance from a map, similar to map->EnumValueDescriptorProto except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EnumValueDescriptorProto-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EnumValueDescriptorProto-spec init))))]}
  (-> (merge EnumValueDescriptorProto-defaults init)
      (cond-> (contains? init :options) (update :options new-EnumValueOptions))
      (map->EnumValueDescriptorProto)))

(defn pb->EnumValueDescriptorProto
  "Protobuf to EnumValueDescriptorProto"
  [input]
  (cis->EnumValueDescriptorProto (stream/new-cis input)))

;-----------------------------------------------------------------------------
; UInt64Value
;-----------------------------------------------------------------------------
(defrecord UInt64Value [value]
  pb/Writer

  (serialize [this os]
    (write-UInt64 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.UInt64Value/value int?)
(s/def ::UInt64Value-spec (s/keys :opt-un [:com.google.protobuf.UInt64Value/value ]))
(def UInt64Value-defaults {:value 0 })

(defn cis->UInt64Value
  "CodedInputStream to UInt64Value"
  [is]
  (->> (tag-map UInt64Value-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->UInt64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->UInt64Value)))

(defn ecis->UInt64Value
  "Embedded CodedInputStream to UInt64Value"
  [is]
  (cis->embedded cis->UInt64Value is))

(defn new-UInt64Value
  "Creates a new instance from a map, similar to map->UInt64Value except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::UInt64Value-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::UInt64Value-spec init))))]}
  (-> (merge UInt64Value-defaults init)
      (map->UInt64Value)))

(defn pb->UInt64Value
  "Protobuf to UInt64Value"
  [input]
  (cis->UInt64Value (stream/new-cis input)))

;-----------------------------------------------------------------------------
; SourceCodeInfo-Location
;-----------------------------------------------------------------------------
(defrecord SourceCodeInfo-Location [path span leading-comments trailing-comments leading-detached-comments]
  pb/Writer

  (serialize [this os]
    (write-repeated write-Int32 1 (:path this) os)
    (write-repeated write-Int32 2 (:span this) os)
    (write-String 3  {:optimize true} (:leading-comments this) os)
    (write-String 4  {:optimize true} (:trailing-comments this) os)
    (write-repeated write-String 6 (:leading-detached-comments this) os)))

(s/def :com.google.protobuf.SourceCodeInfo-Location/path (s/every int?))
(s/def :com.google.protobuf.SourceCodeInfo-Location/span (s/every int?))
(s/def :com.google.protobuf.SourceCodeInfo-Location/leading-comments string?)
(s/def :com.google.protobuf.SourceCodeInfo-Location/trailing-comments string?)
(s/def :com.google.protobuf.SourceCodeInfo-Location/leading-detached-comments (s/every string?))
(s/def ::SourceCodeInfo-Location-spec (s/keys :opt-un [:com.google.protobuf.SourceCodeInfo-Location/path :com.google.protobuf.SourceCodeInfo-Location/span :com.google.protobuf.SourceCodeInfo-Location/leading-comments :com.google.protobuf.SourceCodeInfo-Location/trailing-comments :com.google.protobuf.SourceCodeInfo-Location/leading-detached-comments ]))
(def SourceCodeInfo-Location-defaults {:path [] :span [] :leading-comments "" :trailing-comments "" :leading-detached-comments [] })

(defn cis->SourceCodeInfo-Location
  "CodedInputStream to SourceCodeInfo-Location"
  [is]
  (->> (tag-map SourceCodeInfo-Location-defaults
         (fn [tag index]
             (case index
               1 [:path (cis->packablerepeated tag cis->Int32 is)]
               2 [:span (cis->packablerepeated tag cis->Int32 is)]
               3 [:leading-comments (cis->String is)]
               4 [:trailing-comments (cis->String is)]
               6 [:leading-detached-comments (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->SourceCodeInfo-Location)))

(defn ecis->SourceCodeInfo-Location
  "Embedded CodedInputStream to SourceCodeInfo-Location"
  [is]
  (cis->embedded cis->SourceCodeInfo-Location is))

(defn new-SourceCodeInfo-Location
  "Creates a new instance from a map, similar to map->SourceCodeInfo-Location except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SourceCodeInfo-Location-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SourceCodeInfo-Location-spec init))))]}
  (-> (merge SourceCodeInfo-Location-defaults init)
      (map->SourceCodeInfo-Location)))

(defn pb->SourceCodeInfo-Location
  "Protobuf to SourceCodeInfo-Location"
  [input]
  (cis->SourceCodeInfo-Location (stream/new-cis input)))

;-----------------------------------------------------------------------------
; FieldOptions
;-----------------------------------------------------------------------------
(defrecord FieldOptions [ctype packed jstype lazy deprecated weak uninterpreted-option]
  pb/Writer

  (serialize [this os]
    (write-FieldOptions-CType 1  {:optimize true} (:ctype this) os)
    (write-Bool 2  {:optimize true} (:packed this) os)
    (write-FieldOptions-JSType 6  {:optimize true} (:jstype this) os)
    (write-Bool 5  {:optimize true} (:lazy this) os)
    (write-Bool 3  {:optimize true} (:deprecated this) os)
    (write-Bool 10  {:optimize true} (:weak this) os)
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)))

(s/def :com.google.protobuf.FieldOptions/ctype (s/or :keyword keyword? :int int?))
(s/def :com.google.protobuf.FieldOptions/packed boolean?)
(s/def :com.google.protobuf.FieldOptions/jstype (s/or :keyword keyword? :int int?))
(s/def :com.google.protobuf.FieldOptions/lazy boolean?)
(s/def :com.google.protobuf.FieldOptions/deprecated boolean?)
(s/def :com.google.protobuf.FieldOptions/weak boolean?)

(s/def ::FieldOptions-spec (s/keys :opt-un [:com.google.protobuf.FieldOptions/ctype :com.google.protobuf.FieldOptions/packed :com.google.protobuf.FieldOptions/jstype :com.google.protobuf.FieldOptions/lazy :com.google.protobuf.FieldOptions/deprecated :com.google.protobuf.FieldOptions/weak ]))
(def FieldOptions-defaults {:ctype (FieldOptions-CType-val2label 0) :packed false :jstype (FieldOptions-JSType-val2label 0) :lazy false :deprecated false :weak false :uninterpreted-option [] })

(defn cis->FieldOptions
  "CodedInputStream to FieldOptions"
  [is]
  (->> (tag-map FieldOptions-defaults
         (fn [tag index]
             (case index
               1 [:ctype (cis->FieldOptions-CType is)]
               2 [:packed (cis->Bool is)]
               6 [:jstype (cis->FieldOptions-JSType is)]
               5 [:lazy (cis->Bool is)]
               3 [:deprecated (cis->Bool is)]
               10 [:weak (cis->Bool is)]
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]

               [index (cis->undefined tag is)]))
         is)
        (map->FieldOptions)))

(defn ecis->FieldOptions
  "Embedded CodedInputStream to FieldOptions"
  [is]
  (cis->embedded cis->FieldOptions is))

(defn new-FieldOptions
  "Creates a new instance from a map, similar to map->FieldOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FieldOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FieldOptions-spec init))))]}
  (-> (merge FieldOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->FieldOptions)))

(defn pb->FieldOptions
  "Protobuf to FieldOptions"
  [input]
  (cis->FieldOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; EnumOptions
;-----------------------------------------------------------------------------
(defrecord EnumOptions [allow-alias deprecated uninterpreted-option]
  pb/Writer

  (serialize [this os]
    (write-Bool 2  {:optimize true} (:allow-alias this) os)
    (write-Bool 3  {:optimize true} (:deprecated this) os)
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)))

(s/def :com.google.protobuf.EnumOptions/allow-alias boolean?)
(s/def :com.google.protobuf.EnumOptions/deprecated boolean?)

(s/def ::EnumOptions-spec (s/keys :opt-un [:com.google.protobuf.EnumOptions/allow-alias :com.google.protobuf.EnumOptions/deprecated ]))
(def EnumOptions-defaults {:allow-alias false :deprecated false :uninterpreted-option [] })

(defn cis->EnumOptions
  "CodedInputStream to EnumOptions"
  [is]
  (->> (tag-map EnumOptions-defaults
         (fn [tag index]
             (case index
               2 [:allow-alias (cis->Bool is)]
               3 [:deprecated (cis->Bool is)]
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]

               [index (cis->undefined tag is)]))
         is)
        (map->EnumOptions)))

(defn ecis->EnumOptions
  "Embedded CodedInputStream to EnumOptions"
  [is]
  (cis->embedded cis->EnumOptions is))

(defn new-EnumOptions
  "Creates a new instance from a map, similar to map->EnumOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EnumOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EnumOptions-spec init))))]}
  (-> (merge EnumOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->EnumOptions)))

(defn pb->EnumOptions
  "Protobuf to EnumOptions"
  [input]
  (cis->EnumOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MessageOptions
;-----------------------------------------------------------------------------
(defrecord MessageOptions [message-set-wire-format no-standard-descriptor-accessor deprecated map-entry uninterpreted-option]
  pb/Writer

  (serialize [this os]
    (write-Bool 1  {:optimize true} (:message-set-wire-format this) os)
    (write-Bool 2  {:optimize true} (:no-standard-descriptor-accessor this) os)
    (write-Bool 3  {:optimize true} (:deprecated this) os)
    (write-Bool 7  {:optimize true} (:map-entry this) os)
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)))

(s/def :com.google.protobuf.MessageOptions/message-set-wire-format boolean?)
(s/def :com.google.protobuf.MessageOptions/no-standard-descriptor-accessor boolean?)
(s/def :com.google.protobuf.MessageOptions/deprecated boolean?)
(s/def :com.google.protobuf.MessageOptions/map-entry boolean?)

(s/def ::MessageOptions-spec (s/keys :opt-un [:com.google.protobuf.MessageOptions/message-set-wire-format :com.google.protobuf.MessageOptions/no-standard-descriptor-accessor :com.google.protobuf.MessageOptions/deprecated :com.google.protobuf.MessageOptions/map-entry ]))
(def MessageOptions-defaults {:message-set-wire-format false :no-standard-descriptor-accessor false :deprecated false :map-entry false :uninterpreted-option [] })

(defn cis->MessageOptions
  "CodedInputStream to MessageOptions"
  [is]
  (->> (tag-map MessageOptions-defaults
         (fn [tag index]
             (case index
               1 [:message-set-wire-format (cis->Bool is)]
               2 [:no-standard-descriptor-accessor (cis->Bool is)]
               3 [:deprecated (cis->Bool is)]
               7 [:map-entry (cis->Bool is)]
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MessageOptions)))

(defn ecis->MessageOptions
  "Embedded CodedInputStream to MessageOptions"
  [is]
  (cis->embedded cis->MessageOptions is))

(defn new-MessageOptions
  "Creates a new instance from a map, similar to map->MessageOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MessageOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MessageOptions-spec init))))]}
  (-> (merge MessageOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->MessageOptions)))

(defn pb->MessageOptions
  "Protobuf to MessageOptions"
  [input]
  (cis->MessageOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; BytesValue
;-----------------------------------------------------------------------------
(defrecord BytesValue [value]
  pb/Writer

  (serialize [this os]
    (write-Bytes 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.BytesValue/value bytes?)
(s/def ::BytesValue-spec (s/keys :opt-un [:com.google.protobuf.BytesValue/value ]))
(def BytesValue-defaults {:value (byte-array 0) })

(defn cis->BytesValue
  "CodedInputStream to BytesValue"
  [is]
  (->> (tag-map BytesValue-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->Bytes is)]

               [index (cis->undefined tag is)]))
         is)
        (map->BytesValue)))

(defn ecis->BytesValue
  "Embedded CodedInputStream to BytesValue"
  [is]
  (cis->embedded cis->BytesValue is))

(defn new-BytesValue
  "Creates a new instance from a map, similar to map->BytesValue except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::BytesValue-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::BytesValue-spec init))))]}
  (-> (merge BytesValue-defaults init)
      (map->BytesValue)))

(defn pb->BytesValue
  "Protobuf to BytesValue"
  [input]
  (cis->BytesValue (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Any
;-----------------------------------------------------------------------------
(defrecord Any [type-url value]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:type-url this) os)
    (write-Bytes 2  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.Any/type-url string?)
(s/def :com.google.protobuf.Any/value bytes?)
(s/def ::Any-spec (s/keys :opt-un [:com.google.protobuf.Any/type-url :com.google.protobuf.Any/value ]))
(def Any-defaults {:type-url "" :value (byte-array 0) })

(defn cis->Any
  "CodedInputStream to Any"
  [is]
  (->> (tag-map Any-defaults
         (fn [tag index]
             (case index
               1 [:type-url (cis->String is)]
               2 [:value (cis->Bytes is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Any)))

(defn ecis->Any
  "Embedded CodedInputStream to Any"
  [is]
  (cis->embedded cis->Any is))

(defn new-Any
  "Creates a new instance from a map, similar to map->Any except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Any-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Any-spec init))))]}
  (-> (merge Any-defaults init)
      (map->Any)))

(defn pb->Any
  "Protobuf to Any"
  [input]
  (cis->Any (stream/new-cis input)))

;-----------------------------------------------------------------------------
; EnumDescriptorProto
;-----------------------------------------------------------------------------
(defrecord EnumDescriptorProto [name value options reserved-range reserved-name]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-repeated write-embedded 2 (:value this) os)
    (write-embedded 3 (:options this) os)
    (write-repeated write-embedded 4 (:reserved-range this) os)
    (write-repeated write-String 5 (:reserved-name this) os)))

(s/def :com.google.protobuf.EnumDescriptorProto/name string?)



(s/def :com.google.protobuf.EnumDescriptorProto/reserved-name (s/every string?))
(s/def ::EnumDescriptorProto-spec (s/keys :opt-un [:com.google.protobuf.EnumDescriptorProto/name :com.google.protobuf.EnumDescriptorProto/reserved-name ]))
(def EnumDescriptorProto-defaults {:name "" :value [] :reserved-range [] :reserved-name [] })

(defn cis->EnumDescriptorProto
  "CodedInputStream to EnumDescriptorProto"
  [is]
  (->> (tag-map EnumDescriptorProto-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:value (cis->repeated ecis->EnumValueDescriptorProto is)]
               3 [:options (ecis->EnumOptions is)]
               4 [:reserved-range (cis->repeated ecis->EnumDescriptorProto-EnumReservedRange is)]
               5 [:reserved-name (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->EnumDescriptorProto)))

(defn ecis->EnumDescriptorProto
  "Embedded CodedInputStream to EnumDescriptorProto"
  [is]
  (cis->embedded cis->EnumDescriptorProto is))

(defn new-EnumDescriptorProto
  "Creates a new instance from a map, similar to map->EnumDescriptorProto except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EnumDescriptorProto-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EnumDescriptorProto-spec init))))]}
  (-> (merge EnumDescriptorProto-defaults init)
      (cond-> (contains? init :value) (update :value #(map new-EnumValueDescriptorProto %)))
      (cond-> (contains? init :options) (update :options new-EnumOptions))
      (cond-> (contains? init :reserved-range) (update :reserved-range #(map new-EnumDescriptorProto-EnumReservedRange %)))
      (map->EnumDescriptorProto)))

(defn pb->EnumDescriptorProto
  "Protobuf to EnumDescriptorProto"
  [input]
  (cis->EnumDescriptorProto (stream/new-cis input)))

;-----------------------------------------------------------------------------
; FieldMask
;-----------------------------------------------------------------------------
(defrecord FieldMask [paths]
  pb/Writer

  (serialize [this os]
    (write-repeated write-String 1 (:paths this) os)))

(s/def :com.google.protobuf.FieldMask/paths (s/every string?))
(s/def ::FieldMask-spec (s/keys :opt-un [:com.google.protobuf.FieldMask/paths ]))
(def FieldMask-defaults {:paths [] })

(defn cis->FieldMask
  "CodedInputStream to FieldMask"
  [is]
  (->> (tag-map FieldMask-defaults
         (fn [tag index]
             (case index
               1 [:paths (cis->repeated cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->FieldMask)))

(defn ecis->FieldMask
  "Embedded CodedInputStream to FieldMask"
  [is]
  (cis->embedded cis->FieldMask is))

(defn new-FieldMask
  "Creates a new instance from a map, similar to map->FieldMask except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FieldMask-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FieldMask-spec init))))]}
  (-> (merge FieldMask-defaults init)
      (map->FieldMask)))

(defn pb->FieldMask
  "Protobuf to FieldMask"
  [input]
  (cis->FieldMask (stream/new-cis input)))

;-----------------------------------------------------------------------------
; UninterpretedOption
;-----------------------------------------------------------------------------
(defrecord UninterpretedOption [name identifier-value positive-int-value negative-int-value double-value string-value aggregate-value]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 2 (:name this) os)
    (write-String 3  {:optimize true} (:identifier-value this) os)
    (write-UInt64 4  {:optimize true} (:positive-int-value this) os)
    (write-Int64 5  {:optimize true} (:negative-int-value this) os)
    (write-Double 6  {:optimize true} (:double-value this) os)
    (write-Bytes 7  {:optimize true} (:string-value this) os)
    (write-String 8  {:optimize true} (:aggregate-value this) os)))

(s/def :com.google.protobuf.UninterpretedOption/identifier-value string?)
(s/def :com.google.protobuf.UninterpretedOption/positive-int-value int?)
(s/def :com.google.protobuf.UninterpretedOption/negative-int-value int?)
(s/def :com.google.protobuf.UninterpretedOption/double-value float?)
(s/def :com.google.protobuf.UninterpretedOption/string-value bytes?)
(s/def :com.google.protobuf.UninterpretedOption/aggregate-value string?)
(s/def ::UninterpretedOption-spec (s/keys :opt-un [:com.google.protobuf.UninterpretedOption/identifier-value :com.google.protobuf.UninterpretedOption/positive-int-value :com.google.protobuf.UninterpretedOption/negative-int-value :com.google.protobuf.UninterpretedOption/double-value :com.google.protobuf.UninterpretedOption/string-value :com.google.protobuf.UninterpretedOption/aggregate-value ]))
(def UninterpretedOption-defaults {:name [] :identifier-value "" :positive-int-value 0 :negative-int-value 0 :double-value 0.0 :string-value (byte-array 0) :aggregate-value "" })

(defn cis->UninterpretedOption
  "CodedInputStream to UninterpretedOption"
  [is]
  (->> (tag-map UninterpretedOption-defaults
         (fn [tag index]
             (case index
               2 [:name (cis->repeated ecis->UninterpretedOption-NamePart is)]
               3 [:identifier-value (cis->String is)]
               4 [:positive-int-value (cis->UInt64 is)]
               5 [:negative-int-value (cis->Int64 is)]
               6 [:double-value (cis->Double is)]
               7 [:string-value (cis->Bytes is)]
               8 [:aggregate-value (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->UninterpretedOption)))

(defn ecis->UninterpretedOption
  "Embedded CodedInputStream to UninterpretedOption"
  [is]
  (cis->embedded cis->UninterpretedOption is))

(defn new-UninterpretedOption
  "Creates a new instance from a map, similar to map->UninterpretedOption except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::UninterpretedOption-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::UninterpretedOption-spec init))))]}
  (-> (merge UninterpretedOption-defaults init)
      (cond-> (contains? init :name) (update :name #(map new-UninterpretedOption-NamePart %)))
      (map->UninterpretedOption)))

(defn pb->UninterpretedOption
  "Protobuf to UninterpretedOption"
  [input]
  (cis->UninterpretedOption (stream/new-cis input)))

;-----------------------------------------------------------------------------
; ExtensionRangeOptions
;-----------------------------------------------------------------------------
(defrecord ExtensionRangeOptions [uninterpreted-option]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)))

(s/def ::ExtensionRangeOptions-spec (s/keys :opt-un []))
(def ExtensionRangeOptions-defaults {:uninterpreted-option [] })

(defn cis->ExtensionRangeOptions
  "CodedInputStream to ExtensionRangeOptions"
  [is]
  (->> (tag-map ExtensionRangeOptions-defaults
         (fn [tag index]
             (case index
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]

               [index (cis->undefined tag is)]))
         is)
        (map->ExtensionRangeOptions)))

(defn ecis->ExtensionRangeOptions
  "Embedded CodedInputStream to ExtensionRangeOptions"
  [is]
  (cis->embedded cis->ExtensionRangeOptions is))

(defn new-ExtensionRangeOptions
  "Creates a new instance from a map, similar to map->ExtensionRangeOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ExtensionRangeOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ExtensionRangeOptions-spec init))))]}
  (-> (merge ExtensionRangeOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->ExtensionRangeOptions)))

(defn pb->ExtensionRangeOptions
  "Protobuf to ExtensionRangeOptions"
  [input]
  (cis->ExtensionRangeOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; DoubleValue
;-----------------------------------------------------------------------------
(defrecord DoubleValue [value]
  pb/Writer

  (serialize [this os]
    (write-Double 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.DoubleValue/value float?)
(s/def ::DoubleValue-spec (s/keys :opt-un [:com.google.protobuf.DoubleValue/value ]))
(def DoubleValue-defaults {:value 0.0 })

(defn cis->DoubleValue
  "CodedInputStream to DoubleValue"
  [is]
  (->> (tag-map DoubleValue-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->Double is)]

               [index (cis->undefined tag is)]))
         is)
        (map->DoubleValue)))

(defn ecis->DoubleValue
  "Embedded CodedInputStream to DoubleValue"
  [is]
  (cis->embedded cis->DoubleValue is))

(defn new-DoubleValue
  "Creates a new instance from a map, similar to map->DoubleValue except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DoubleValue-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DoubleValue-spec init))))]}
  (-> (merge DoubleValue-defaults init)
      (map->DoubleValue)))

(defn pb->DoubleValue
  "Protobuf to DoubleValue"
  [input]
  (cis->DoubleValue (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Value
;-----------------------------------------------------------------------------
(defrecord Value [kind]
  pb/Writer

  (serialize [this os]
    (write-kind  (:kind this) os)))

(s/def ::Value-spec (s/keys :opt-un []))
(def Value-defaults {})

(defn cis->Value
  "CodedInputStream to Value"
  [is]
  (->> (tag-map Value-defaults
         (fn [tag index]
             (case index
               1 [:kind {:null-value (cis->NullValue is)}]
               2 [:kind {:number-value (cis->Double is)}]
               3 [:kind {:string-value (cis->String is)}]
               4 [:kind {:bool-value (cis->Bool is)}]
               5 [:kind {:struct-value (ecis->Struct is)}]
               6 [:kind {:list-value (ecis->ListValue is)}]

               [index (cis->undefined tag is)]))
         is)
        (map->Value)))

(defn ecis->Value
  "Embedded CodedInputStream to Value"
  [is]
  (cis->embedded cis->Value is))

(defn new-Value
  "Creates a new instance from a map, similar to map->Value except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Value-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Value-spec init))))]}
  (-> (merge Value-defaults init)
      (convert-kind)
      (map->Value)))

(defn pb->Value
  "Protobuf to Value"
  [input]
  (cis->Value (stream/new-cis input)))

;-----------------------------------------------------------------------------
; DescriptorProto
;-----------------------------------------------------------------------------
(defrecord DescriptorProto [reserved-range enum-type reserved-name extension-range name extension field options oneof-decl nested-type]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 9 (:reserved-range this) os)
    (write-repeated write-embedded 4 (:enum-type this) os)
    (write-repeated write-String 10 (:reserved-name this) os)
    (write-repeated write-embedded 5 (:extension-range this) os)
    (write-String 1  {:optimize true} (:name this) os)
    (write-repeated write-embedded 6 (:extension this) os)
    (write-repeated write-embedded 2 (:field this) os)
    (write-embedded 7 (:options this) os)
    (write-repeated write-embedded 8 (:oneof-decl this) os)
    (write-repeated write-embedded 3 (:nested-type this) os)))

(s/def :com.google.protobuf.DescriptorProto/reserved-name (s/every string?))

(s/def :com.google.protobuf.DescriptorProto/name string?)





(s/def ::DescriptorProto-spec (s/keys :opt-un [:com.google.protobuf.DescriptorProto/reserved-name :com.google.protobuf.DescriptorProto/name ]))
(def DescriptorProto-defaults {:reserved-range [] :enum-type [] :reserved-name [] :extension-range [] :name "" :extension [] :field [] :oneof-decl [] :nested-type [] })

(defn cis->DescriptorProto
  "CodedInputStream to DescriptorProto"
  [is]
  (->> (tag-map DescriptorProto-defaults
         (fn [tag index]
             (case index
               9 [:reserved-range (cis->repeated ecis->DescriptorProto-ReservedRange is)]
               4 [:enum-type (cis->repeated ecis->EnumDescriptorProto is)]
               10 [:reserved-name (cis->repeated cis->String is)]
               5 [:extension-range (cis->repeated ecis->DescriptorProto-ExtensionRange is)]
               1 [:name (cis->String is)]
               6 [:extension (cis->repeated ecis->FieldDescriptorProto is)]
               2 [:field (cis->repeated ecis->FieldDescriptorProto is)]
               7 [:options (ecis->MessageOptions is)]
               8 [:oneof-decl (cis->repeated ecis->OneofDescriptorProto is)]
               3 [:nested-type (cis->repeated ecis->DescriptorProto is)]

               [index (cis->undefined tag is)]))
         is)
        (map->DescriptorProto)))

(defn ecis->DescriptorProto
  "Embedded CodedInputStream to DescriptorProto"
  [is]
  (cis->embedded cis->DescriptorProto is))

(defn new-DescriptorProto
  "Creates a new instance from a map, similar to map->DescriptorProto except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DescriptorProto-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DescriptorProto-spec init))))]}
  (-> (merge DescriptorProto-defaults init)
      (cond-> (contains? init :field) (update :field #(map new-FieldDescriptorProto %)))
      (cond-> (contains? init :extension) (update :extension #(map new-FieldDescriptorProto %)))
      (cond-> (contains? init :nested-type) (update :nested-type #(map new-DescriptorProto %)))
      (cond-> (contains? init :enum-type) (update :enum-type #(map new-EnumDescriptorProto %)))
      (cond-> (contains? init :extension-range) (update :extension-range #(map new-DescriptorProto-ExtensionRange %)))
      (cond-> (contains? init :oneof-decl) (update :oneof-decl #(map new-OneofDescriptorProto %)))
      (cond-> (contains? init :options) (update :options new-MessageOptions))
      (cond-> (contains? init :reserved-range) (update :reserved-range #(map new-DescriptorProto-ReservedRange %)))
      (map->DescriptorProto)))

(defn pb->DescriptorProto
  "Protobuf to DescriptorProto"
  [input]
  (cis->DescriptorProto (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Method
;-----------------------------------------------------------------------------
(defrecord Method [name request-type-url request-streaming response-type-url response-streaming options syntax]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-String 2  {:optimize true} (:request-type-url this) os)
    (write-Bool 3  {:optimize true} (:request-streaming this) os)
    (write-String 4  {:optimize true} (:response-type-url this) os)
    (write-Bool 5  {:optimize true} (:response-streaming this) os)
    (write-repeated write-embedded 6 (:options this) os)
    (write-Syntax 7  {:optimize true} (:syntax this) os)))

(s/def :com.google.protobuf.Method/name string?)
(s/def :com.google.protobuf.Method/request-type-url string?)
(s/def :com.google.protobuf.Method/request-streaming boolean?)
(s/def :com.google.protobuf.Method/response-type-url string?)
(s/def :com.google.protobuf.Method/response-streaming boolean?)

(s/def :com.google.protobuf.Method/syntax (s/or :keyword keyword? :int int?))
(s/def ::Method-spec (s/keys :opt-un [:com.google.protobuf.Method/name :com.google.protobuf.Method/request-type-url :com.google.protobuf.Method/request-streaming :com.google.protobuf.Method/response-type-url :com.google.protobuf.Method/response-streaming :com.google.protobuf.Method/syntax ]))
(def Method-defaults {:name "" :request-type-url "" :request-streaming false :response-type-url "" :response-streaming false :options [] :syntax (Syntax-val2label 0) })

(defn cis->Method
  "CodedInputStream to Method"
  [is]
  (->> (tag-map Method-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:request-type-url (cis->String is)]
               3 [:request-streaming (cis->Bool is)]
               4 [:response-type-url (cis->String is)]
               5 [:response-streaming (cis->Bool is)]
               6 [:options (cis->repeated ecis->Option is)]
               7 [:syntax (cis->Syntax is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Method)))

(defn ecis->Method
  "Embedded CodedInputStream to Method"
  [is]
  (cis->embedded cis->Method is))

(defn new-Method
  "Creates a new instance from a map, similar to map->Method except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Method-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Method-spec init))))]}
  (-> (merge Method-defaults init)
      (cond-> (contains? init :options) (update :options #(map new-Option %)))
      (map->Method)))

(defn pb->Method
  "Protobuf to Method"
  [input]
  (cis->Method (stream/new-cis input)))

;-----------------------------------------------------------------------------
; OneofOptions
;-----------------------------------------------------------------------------
(defrecord OneofOptions [uninterpreted-option]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)))

(s/def ::OneofOptions-spec (s/keys :opt-un []))
(def OneofOptions-defaults {:uninterpreted-option [] })

(defn cis->OneofOptions
  "CodedInputStream to OneofOptions"
  [is]
  (->> (tag-map OneofOptions-defaults
         (fn [tag index]
             (case index
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]

               [index (cis->undefined tag is)]))
         is)
        (map->OneofOptions)))

(defn ecis->OneofOptions
  "Embedded CodedInputStream to OneofOptions"
  [is]
  (cis->embedded cis->OneofOptions is))

(defn new-OneofOptions
  "Creates a new instance from a map, similar to map->OneofOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OneofOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OneofOptions-spec init))))]}
  (-> (merge OneofOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->OneofOptions)))

(defn pb->OneofOptions
  "Protobuf to OneofOptions"
  [input]
  (cis->OneofOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; SourceContext
;-----------------------------------------------------------------------------
(defrecord SourceContext [file-name]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:file-name this) os)))

(s/def :com.google.protobuf.SourceContext/file-name string?)
(s/def ::SourceContext-spec (s/keys :opt-un [:com.google.protobuf.SourceContext/file-name ]))
(def SourceContext-defaults {:file-name "" })

(defn cis->SourceContext
  "CodedInputStream to SourceContext"
  [is]
  (->> (tag-map SourceContext-defaults
         (fn [tag index]
             (case index
               1 [:file-name (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->SourceContext)))

(defn ecis->SourceContext
  "Embedded CodedInputStream to SourceContext"
  [is]
  (cis->embedded cis->SourceContext is))

(defn new-SourceContext
  "Creates a new instance from a map, similar to map->SourceContext except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SourceContext-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SourceContext-spec init))))]}
  (-> (merge SourceContext-defaults init)
      (map->SourceContext)))

(defn pb->SourceContext
  "Protobuf to SourceContext"
  [input]
  (cis->SourceContext (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Duration
;-----------------------------------------------------------------------------
(defrecord Duration [seconds nanos]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:seconds this) os)
    (write-Int32 2  {:optimize true} (:nanos this) os)))

(s/def :com.google.protobuf.Duration/seconds int?)
(s/def :com.google.protobuf.Duration/nanos int?)
(s/def ::Duration-spec (s/keys :opt-un [:com.google.protobuf.Duration/seconds :com.google.protobuf.Duration/nanos ]))
(def Duration-defaults {:seconds 0 :nanos 0 })

(defn cis->Duration
  "CodedInputStream to Duration"
  [is]
  (->> (tag-map Duration-defaults
         (fn [tag index]
             (case index
               1 [:seconds (cis->Int64 is)]
               2 [:nanos (cis->Int32 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Duration)))

(defn ecis->Duration
  "Embedded CodedInputStream to Duration"
  [is]
  (cis->embedded cis->Duration is))

(defn new-Duration
  "Creates a new instance from a map, similar to map->Duration except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Duration-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Duration-spec init))))]}
  (-> (merge Duration-defaults init)
      (map->Duration)))

(defn pb->Duration
  "Protobuf to Duration"
  [input]
  (cis->Duration (stream/new-cis input)))

;-----------------------------------------------------------------------------
; MethodDescriptorProto
;-----------------------------------------------------------------------------
(defrecord MethodDescriptorProto [name input-type output-type options client-streaming server-streaming]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-String 2  {:optimize true} (:input-type this) os)
    (write-String 3  {:optimize true} (:output-type this) os)
    (write-embedded 4 (:options this) os)
    (write-Bool 5  {:optimize true} (:client-streaming this) os)
    (write-Bool 6  {:optimize true} (:server-streaming this) os)))

(s/def :com.google.protobuf.MethodDescriptorProto/name string?)
(s/def :com.google.protobuf.MethodDescriptorProto/input-type string?)
(s/def :com.google.protobuf.MethodDescriptorProto/output-type string?)

(s/def :com.google.protobuf.MethodDescriptorProto/client-streaming boolean?)
(s/def :com.google.protobuf.MethodDescriptorProto/server-streaming boolean?)
(s/def ::MethodDescriptorProto-spec (s/keys :opt-un [:com.google.protobuf.MethodDescriptorProto/name :com.google.protobuf.MethodDescriptorProto/input-type :com.google.protobuf.MethodDescriptorProto/output-type :com.google.protobuf.MethodDescriptorProto/client-streaming :com.google.protobuf.MethodDescriptorProto/server-streaming ]))
(def MethodDescriptorProto-defaults {:name "" :input-type "" :output-type "" :client-streaming false :server-streaming false })

(defn cis->MethodDescriptorProto
  "CodedInputStream to MethodDescriptorProto"
  [is]
  (->> (tag-map MethodDescriptorProto-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:input-type (cis->String is)]
               3 [:output-type (cis->String is)]
               4 [:options (ecis->MethodOptions is)]
               5 [:client-streaming (cis->Bool is)]
               6 [:server-streaming (cis->Bool is)]

               [index (cis->undefined tag is)]))
         is)
        (map->MethodDescriptorProto)))

(defn ecis->MethodDescriptorProto
  "Embedded CodedInputStream to MethodDescriptorProto"
  [is]
  (cis->embedded cis->MethodDescriptorProto is))

(defn new-MethodDescriptorProto
  "Creates a new instance from a map, similar to map->MethodDescriptorProto except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::MethodDescriptorProto-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::MethodDescriptorProto-spec init))))]}
  (-> (merge MethodDescriptorProto-defaults init)
      (cond-> (contains? init :options) (update :options new-MethodOptions))
      (map->MethodDescriptorProto)))

(defn pb->MethodDescriptorProto
  "Protobuf to MethodDescriptorProto"
  [input]
  (cis->MethodDescriptorProto (stream/new-cis input)))

;-----------------------------------------------------------------------------
; OneofDescriptorProto
;-----------------------------------------------------------------------------
(defrecord OneofDescriptorProto [name options]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-embedded 2 (:options this) os)))

(s/def :com.google.protobuf.OneofDescriptorProto/name string?)

(s/def ::OneofDescriptorProto-spec (s/keys :opt-un [:com.google.protobuf.OneofDescriptorProto/name ]))
(def OneofDescriptorProto-defaults {:name "" })

(defn cis->OneofDescriptorProto
  "CodedInputStream to OneofDescriptorProto"
  [is]
  (->> (tag-map OneofDescriptorProto-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:options (ecis->OneofOptions is)]

               [index (cis->undefined tag is)]))
         is)
        (map->OneofDescriptorProto)))

(defn ecis->OneofDescriptorProto
  "Embedded CodedInputStream to OneofDescriptorProto"
  [is]
  (cis->embedded cis->OneofDescriptorProto is))

(defn new-OneofDescriptorProto
  "Creates a new instance from a map, similar to map->OneofDescriptorProto except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OneofDescriptorProto-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OneofDescriptorProto-spec init))))]}
  (-> (merge OneofDescriptorProto-defaults init)
      (cond-> (contains? init :options) (update :options new-OneofOptions))
      (map->OneofDescriptorProto)))

(defn pb->OneofDescriptorProto
  "Protobuf to OneofDescriptorProto"
  [input]
  (cis->OneofDescriptorProto (stream/new-cis input)))

;-----------------------------------------------------------------------------
; FileDescriptorProto
;-----------------------------------------------------------------------------
(defrecord FileDescriptorProto [package message-type source-code-info enum-type name extension dependency syntax weak-dependency public-dependency service options]
  pb/Writer

  (serialize [this os]
    (write-String 2  {:optimize true} (:package this) os)
    (write-repeated write-embedded 4 (:message-type this) os)
    (write-embedded 9 (:source-code-info this) os)
    (write-repeated write-embedded 5 (:enum-type this) os)
    (write-String 1  {:optimize true} (:name this) os)
    (write-repeated write-embedded 7 (:extension this) os)
    (write-repeated write-String 3 (:dependency this) os)
    (write-String 12  {:optimize true} (:syntax this) os)
    (write-repeated write-Int32 11 (:weak-dependency this) os)
    (write-repeated write-Int32 10 (:public-dependency this) os)
    (write-repeated write-embedded 6 (:service this) os)
    (write-embedded 8 (:options this) os)))

(s/def :com.google.protobuf.FileDescriptorProto/package string?)



(s/def :com.google.protobuf.FileDescriptorProto/name string?)

(s/def :com.google.protobuf.FileDescriptorProto/dependency (s/every string?))
(s/def :com.google.protobuf.FileDescriptorProto/syntax string?)
(s/def :com.google.protobuf.FileDescriptorProto/weak-dependency (s/every int?))
(s/def :com.google.protobuf.FileDescriptorProto/public-dependency (s/every int?))


(s/def ::FileDescriptorProto-spec (s/keys :opt-un [:com.google.protobuf.FileDescriptorProto/package :com.google.protobuf.FileDescriptorProto/name :com.google.protobuf.FileDescriptorProto/dependency :com.google.protobuf.FileDescriptorProto/syntax :com.google.protobuf.FileDescriptorProto/weak-dependency :com.google.protobuf.FileDescriptorProto/public-dependency ]))
(def FileDescriptorProto-defaults {:package "" :message-type [] :enum-type [] :name "" :extension [] :dependency [] :syntax "" :weak-dependency [] :public-dependency [] :service [] })

(defn cis->FileDescriptorProto
  "CodedInputStream to FileDescriptorProto"
  [is]
  (->> (tag-map FileDescriptorProto-defaults
         (fn [tag index]
             (case index
               2 [:package (cis->String is)]
               4 [:message-type (cis->repeated ecis->DescriptorProto is)]
               9 [:source-code-info (ecis->SourceCodeInfo is)]
               5 [:enum-type (cis->repeated ecis->EnumDescriptorProto is)]
               1 [:name (cis->String is)]
               7 [:extension (cis->repeated ecis->FieldDescriptorProto is)]
               3 [:dependency (cis->repeated cis->String is)]
               12 [:syntax (cis->String is)]
               11 [:weak-dependency (cis->packablerepeated tag cis->Int32 is)]
               10 [:public-dependency (cis->packablerepeated tag cis->Int32 is)]
               6 [:service (cis->repeated ecis->ServiceDescriptorProto is)]
               8 [:options (ecis->FileOptions is)]

               [index (cis->undefined tag is)]))
         is)
        (map->FileDescriptorProto)))

(defn ecis->FileDescriptorProto
  "Embedded CodedInputStream to FileDescriptorProto"
  [is]
  (cis->embedded cis->FileDescriptorProto is))

(defn new-FileDescriptorProto
  "Creates a new instance from a map, similar to map->FileDescriptorProto except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FileDescriptorProto-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FileDescriptorProto-spec init))))]}
  (-> (merge FileDescriptorProto-defaults init)
      (cond-> (contains? init :message-type) (update :message-type #(map new-DescriptorProto %)))
      (cond-> (contains? init :enum-type) (update :enum-type #(map new-EnumDescriptorProto %)))
      (cond-> (contains? init :service) (update :service #(map new-ServiceDescriptorProto %)))
      (cond-> (contains? init :extension) (update :extension #(map new-FieldDescriptorProto %)))
      (cond-> (contains? init :options) (update :options new-FileOptions))
      (cond-> (contains? init :source-code-info) (update :source-code-info new-SourceCodeInfo))
      (map->FileDescriptorProto)))

(defn pb->FileDescriptorProto
  "Protobuf to FileDescriptorProto"
  [input]
  (cis->FileDescriptorProto (stream/new-cis input)))

;-----------------------------------------------------------------------------
; DescriptorProto-ReservedRange
;-----------------------------------------------------------------------------
(defrecord DescriptorProto-ReservedRange [start end]
  pb/Writer

  (serialize [this os]
    (write-Int32 1  {:optimize true} (:start this) os)
    (write-Int32 2  {:optimize true} (:end this) os)))

(s/def :com.google.protobuf.DescriptorProto-ReservedRange/start int?)
(s/def :com.google.protobuf.DescriptorProto-ReservedRange/end int?)
(s/def ::DescriptorProto-ReservedRange-spec (s/keys :opt-un [:com.google.protobuf.DescriptorProto-ReservedRange/start :com.google.protobuf.DescriptorProto-ReservedRange/end ]))
(def DescriptorProto-ReservedRange-defaults {:start 0 :end 0 })

(defn cis->DescriptorProto-ReservedRange
  "CodedInputStream to DescriptorProto-ReservedRange"
  [is]
  (->> (tag-map DescriptorProto-ReservedRange-defaults
         (fn [tag index]
             (case index
               1 [:start (cis->Int32 is)]
               2 [:end (cis->Int32 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->DescriptorProto-ReservedRange)))

(defn ecis->DescriptorProto-ReservedRange
  "Embedded CodedInputStream to DescriptorProto-ReservedRange"
  [is]
  (cis->embedded cis->DescriptorProto-ReservedRange is))

(defn new-DescriptorProto-ReservedRange
  "Creates a new instance from a map, similar to map->DescriptorProto-ReservedRange except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::DescriptorProto-ReservedRange-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::DescriptorProto-ReservedRange-spec init))))]}
  (-> (merge DescriptorProto-ReservedRange-defaults init)
      (map->DescriptorProto-ReservedRange)))

(defn pb->DescriptorProto-ReservedRange
  "Protobuf to DescriptorProto-ReservedRange"
  [input]
  (cis->DescriptorProto-ReservedRange (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Int64Value
;-----------------------------------------------------------------------------
(defrecord Int64Value [value]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.Int64Value/value int?)
(s/def ::Int64Value-spec (s/keys :opt-un [:com.google.protobuf.Int64Value/value ]))
(def Int64Value-defaults {:value 0 })

(defn cis->Int64Value
  "CodedInputStream to Int64Value"
  [is]
  (->> (tag-map Int64Value-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->Int64 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Int64Value)))

(defn ecis->Int64Value
  "Embedded CodedInputStream to Int64Value"
  [is]
  (cis->embedded cis->Int64Value is))

(defn new-Int64Value
  "Creates a new instance from a map, similar to map->Int64Value except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Int64Value-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Int64Value-spec init))))]}
  (-> (merge Int64Value-defaults init)
      (map->Int64Value)))

(defn pb->Int64Value
  "Protobuf to Int64Value"
  [input]
  (cis->Int64Value (stream/new-cis input)))

;-----------------------------------------------------------------------------
; EnumValueOptions
;-----------------------------------------------------------------------------
(defrecord EnumValueOptions [deprecated uninterpreted-option]
  pb/Writer

  (serialize [this os]
    (write-Bool 1  {:optimize true} (:deprecated this) os)
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)))

(s/def :com.google.protobuf.EnumValueOptions/deprecated boolean?)

(s/def ::EnumValueOptions-spec (s/keys :opt-un [:com.google.protobuf.EnumValueOptions/deprecated ]))
(def EnumValueOptions-defaults {:deprecated false :uninterpreted-option [] })

(defn cis->EnumValueOptions
  "CodedInputStream to EnumValueOptions"
  [is]
  (->> (tag-map EnumValueOptions-defaults
         (fn [tag index]
             (case index
               1 [:deprecated (cis->Bool is)]
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]

               [index (cis->undefined tag is)]))
         is)
        (map->EnumValueOptions)))

(defn ecis->EnumValueOptions
  "Embedded CodedInputStream to EnumValueOptions"
  [is]
  (cis->embedded cis->EnumValueOptions is))

(defn new-EnumValueOptions
  "Creates a new instance from a map, similar to map->EnumValueOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EnumValueOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EnumValueOptions-spec init))))]}
  (-> (merge EnumValueOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->EnumValueOptions)))

(defn pb->EnumValueOptions
  "Protobuf to EnumValueOptions"
  [input]
  (cis->EnumValueOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; UInt32Value
;-----------------------------------------------------------------------------
(defrecord UInt32Value [value]
  pb/Writer

  (serialize [this os]
    (write-UInt32 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.UInt32Value/value int?)
(s/def ::UInt32Value-spec (s/keys :opt-un [:com.google.protobuf.UInt32Value/value ]))
(def UInt32Value-defaults {:value 0 })

(defn cis->UInt32Value
  "CodedInputStream to UInt32Value"
  [is]
  (->> (tag-map UInt32Value-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->UInt32 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->UInt32Value)))

(defn ecis->UInt32Value
  "Embedded CodedInputStream to UInt32Value"
  [is]
  (cis->embedded cis->UInt32Value is))

(defn new-UInt32Value
  "Creates a new instance from a map, similar to map->UInt32Value except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::UInt32Value-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::UInt32Value-spec init))))]}
  (-> (merge UInt32Value-defaults init)
      (map->UInt32Value)))

(defn pb->UInt32Value
  "Protobuf to UInt32Value"
  [input]
  (cis->UInt32Value (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Enum
;-----------------------------------------------------------------------------
(defrecord Enum [name enumvalue options source-context syntax]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:name this) os)
    (write-repeated write-embedded 2 (:enumvalue this) os)
    (write-repeated write-embedded 3 (:options this) os)
    (write-embedded 4 (:source-context this) os)
    (write-Syntax 5  {:optimize true} (:syntax this) os)))

(s/def :com.google.protobuf.Enum/name string?)



(s/def :com.google.protobuf.Enum/syntax (s/or :keyword keyword? :int int?))
(s/def ::Enum-spec (s/keys :opt-un [:com.google.protobuf.Enum/name :com.google.protobuf.Enum/syntax ]))
(def Enum-defaults {:name "" :enumvalue [] :options [] :syntax (Syntax-val2label 0) })

(defn cis->Enum
  "CodedInputStream to Enum"
  [is]
  (->> (tag-map Enum-defaults
         (fn [tag index]
             (case index
               1 [:name (cis->String is)]
               2 [:enumvalue (cis->repeated ecis->EnumValue is)]
               3 [:options (cis->repeated ecis->Option is)]
               4 [:source-context (ecis->SourceContext is)]
               5 [:syntax (cis->Syntax is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Enum)))

(defn ecis->Enum
  "Embedded CodedInputStream to Enum"
  [is]
  (cis->embedded cis->Enum is))

(defn new-Enum
  "Creates a new instance from a map, similar to map->Enum except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Enum-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Enum-spec init))))]}
  (-> (merge Enum-defaults init)
      (cond-> (contains? init :enumvalue) (update :enumvalue #(map new-EnumValue %)))
      (cond-> (contains? init :options) (update :options #(map new-Option %)))
      (cond-> (contains? init :source-context) (update :source-context new-SourceContext))
      (map->Enum)))

(defn pb->Enum
  "Protobuf to Enum"
  [input]
  (cis->Enum (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Timestamp
;-----------------------------------------------------------------------------
(defrecord Timestamp [seconds nanos]
  pb/Writer

  (serialize [this os]
    (write-Int64 1  {:optimize true} (:seconds this) os)
    (write-Int32 2  {:optimize true} (:nanos this) os)))

(s/def :com.google.protobuf.Timestamp/seconds int?)
(s/def :com.google.protobuf.Timestamp/nanos int?)
(s/def ::Timestamp-spec (s/keys :opt-un [:com.google.protobuf.Timestamp/seconds :com.google.protobuf.Timestamp/nanos ]))
(def Timestamp-defaults {:seconds 0 :nanos 0 })

(defn cis->Timestamp
  "CodedInputStream to Timestamp"
  [is]
  (->> (tag-map Timestamp-defaults
         (fn [tag index]
             (case index
               1 [:seconds (cis->Int64 is)]
               2 [:nanos (cis->Int32 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Timestamp)))

(defn ecis->Timestamp
  "Embedded CodedInputStream to Timestamp"
  [is]
  (cis->embedded cis->Timestamp is))

(defn new-Timestamp
  "Creates a new instance from a map, similar to map->Timestamp except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Timestamp-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Timestamp-spec init))))]}
  (-> (merge Timestamp-defaults init)
      (map->Timestamp)))

(defn pb->Timestamp
  "Protobuf to Timestamp"
  [input]
  (cis->Timestamp (stream/new-cis input)))

;-----------------------------------------------------------------------------
; FieldDescriptorProto
;-----------------------------------------------------------------------------
(defrecord FieldDescriptorProto [label json-name name oneof-index number type-name type options extendee default-value]
  pb/Writer

  (serialize [this os]
    (write-FieldDescriptorProto-Label 4  {:optimize true} (:label this) os)
    (write-String 10  {:optimize true} (:json-name this) os)
    (write-String 1  {:optimize true} (:name this) os)
    (write-Int32 9  {:optimize true} (:oneof-index this) os)
    (write-Int32 3  {:optimize true} (:number this) os)
    (write-String 6  {:optimize true} (:type-name this) os)
    (write-FieldDescriptorProto-Type 5  {:optimize true} (:type this) os)
    (write-embedded 8 (:options this) os)
    (write-String 2  {:optimize true} (:extendee this) os)
    (write-String 7  {:optimize true} (:default-value this) os)))

(s/def :com.google.protobuf.FieldDescriptorProto/label (s/or :keyword keyword? :int int?))
(s/def :com.google.protobuf.FieldDescriptorProto/json-name string?)
(s/def :com.google.protobuf.FieldDescriptorProto/name string?)
(s/def :com.google.protobuf.FieldDescriptorProto/oneof-index int?)
(s/def :com.google.protobuf.FieldDescriptorProto/number int?)
(s/def :com.google.protobuf.FieldDescriptorProto/type-name string?)
(s/def :com.google.protobuf.FieldDescriptorProto/type (s/or :keyword keyword? :int int?))

(s/def :com.google.protobuf.FieldDescriptorProto/extendee string?)
(s/def :com.google.protobuf.FieldDescriptorProto/default-value string?)
(s/def ::FieldDescriptorProto-spec (s/keys :opt-un [:com.google.protobuf.FieldDescriptorProto/label :com.google.protobuf.FieldDescriptorProto/json-name :com.google.protobuf.FieldDescriptorProto/name :com.google.protobuf.FieldDescriptorProto/oneof-index :com.google.protobuf.FieldDescriptorProto/number :com.google.protobuf.FieldDescriptorProto/type-name :com.google.protobuf.FieldDescriptorProto/type :com.google.protobuf.FieldDescriptorProto/extendee :com.google.protobuf.FieldDescriptorProto/default-value ]))
(def FieldDescriptorProto-defaults {:label (FieldDescriptorProto-Label-val2label 0) :json-name "" :name "" :oneof-index 0 :number 0 :type-name "" :type (FieldDescriptorProto-Type-val2label 0) :extendee "" :default-value "" })

(defn cis->FieldDescriptorProto
  "CodedInputStream to FieldDescriptorProto"
  [is]
  (->> (tag-map FieldDescriptorProto-defaults
         (fn [tag index]
             (case index
               4 [:label (cis->FieldDescriptorProto-Label is)]
               10 [:json-name (cis->String is)]
               1 [:name (cis->String is)]
               9 [:oneof-index (cis->Int32 is)]
               3 [:number (cis->Int32 is)]
               6 [:type-name (cis->String is)]
               5 [:type (cis->FieldDescriptorProto-Type is)]
               8 [:options (ecis->FieldOptions is)]
               2 [:extendee (cis->String is)]
               7 [:default-value (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->FieldDescriptorProto)))

(defn ecis->FieldDescriptorProto
  "Embedded CodedInputStream to FieldDescriptorProto"
  [is]
  (cis->embedded cis->FieldDescriptorProto is))

(defn new-FieldDescriptorProto
  "Creates a new instance from a map, similar to map->FieldDescriptorProto except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FieldDescriptorProto-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FieldDescriptorProto-spec init))))]}
  (-> (merge FieldDescriptorProto-defaults init)
      (cond-> (contains? init :options) (update :options new-FieldOptions))
      (map->FieldDescriptorProto)))

(defn pb->FieldDescriptorProto
  "Protobuf to FieldDescriptorProto"
  [input]
  (cis->FieldDescriptorProto (stream/new-cis input)))

;-----------------------------------------------------------------------------
; GeneratedCodeInfo
;-----------------------------------------------------------------------------
(defrecord GeneratedCodeInfo [annotation]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 1 (:annotation this) os)))

(s/def ::GeneratedCodeInfo-spec (s/keys :opt-un []))
(def GeneratedCodeInfo-defaults {:annotation [] })

(defn cis->GeneratedCodeInfo
  "CodedInputStream to GeneratedCodeInfo"
  [is]
  (->> (tag-map GeneratedCodeInfo-defaults
         (fn [tag index]
             (case index
               1 [:annotation (cis->repeated ecis->GeneratedCodeInfo-Annotation is)]

               [index (cis->undefined tag is)]))
         is)
        (map->GeneratedCodeInfo)))

(defn ecis->GeneratedCodeInfo
  "Embedded CodedInputStream to GeneratedCodeInfo"
  [is]
  (cis->embedded cis->GeneratedCodeInfo is))

(defn new-GeneratedCodeInfo
  "Creates a new instance from a map, similar to map->GeneratedCodeInfo except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::GeneratedCodeInfo-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::GeneratedCodeInfo-spec init))))]}
  (-> (merge GeneratedCodeInfo-defaults init)
      (cond-> (contains? init :annotation) (update :annotation #(map new-GeneratedCodeInfo-Annotation %)))
      (map->GeneratedCodeInfo)))

(defn pb->GeneratedCodeInfo
  "Protobuf to GeneratedCodeInfo"
  [input]
  (cis->GeneratedCodeInfo (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Field
;-----------------------------------------------------------------------------
(defrecord Field [type-url json-name packed name oneof-index number kind cardinality options default-value]
  pb/Writer

  (serialize [this os]
    (write-String 6  {:optimize true} (:type-url this) os)
    (write-String 10  {:optimize true} (:json-name this) os)
    (write-Bool 8  {:optimize true} (:packed this) os)
    (write-String 4  {:optimize true} (:name this) os)
    (write-Int32 7  {:optimize true} (:oneof-index this) os)
    (write-Int32 3  {:optimize true} (:number this) os)
    (write-Field-Kind 1  {:optimize true} (:kind this) os)
    (write-Field-Cardinality 2  {:optimize true} (:cardinality this) os)
    (write-repeated write-embedded 9 (:options this) os)
    (write-String 11  {:optimize true} (:default-value this) os)))

(s/def :com.google.protobuf.Field/type-url string?)
(s/def :com.google.protobuf.Field/json-name string?)
(s/def :com.google.protobuf.Field/packed boolean?)
(s/def :com.google.protobuf.Field/name string?)
(s/def :com.google.protobuf.Field/oneof-index int?)
(s/def :com.google.protobuf.Field/number int?)
(s/def :com.google.protobuf.Field/kind (s/or :keyword keyword? :int int?))
(s/def :com.google.protobuf.Field/cardinality (s/or :keyword keyword? :int int?))

(s/def :com.google.protobuf.Field/default-value string?)
(s/def ::Field-spec (s/keys :opt-un [:com.google.protobuf.Field/type-url :com.google.protobuf.Field/json-name :com.google.protobuf.Field/packed :com.google.protobuf.Field/name :com.google.protobuf.Field/oneof-index :com.google.protobuf.Field/number :com.google.protobuf.Field/kind :com.google.protobuf.Field/cardinality :com.google.protobuf.Field/default-value ]))
(def Field-defaults {:type-url "" :json-name "" :packed false :name "" :oneof-index 0 :number 0 :kind (Field-Kind-val2label 0) :cardinality (Field-Cardinality-val2label 0) :options [] :default-value "" })

(defn cis->Field
  "CodedInputStream to Field"
  [is]
  (->> (tag-map Field-defaults
         (fn [tag index]
             (case index
               6 [:type-url (cis->String is)]
               10 [:json-name (cis->String is)]
               8 [:packed (cis->Bool is)]
               4 [:name (cis->String is)]
               7 [:oneof-index (cis->Int32 is)]
               3 [:number (cis->Int32 is)]
               1 [:kind (cis->Field-Kind is)]
               2 [:cardinality (cis->Field-Cardinality is)]
               9 [:options (cis->repeated ecis->Option is)]
               11 [:default-value (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Field)))

(defn ecis->Field
  "Embedded CodedInputStream to Field"
  [is]
  (cis->embedded cis->Field is))

(defn new-Field
  "Creates a new instance from a map, similar to map->Field except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Field-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Field-spec init))))]}
  (-> (merge Field-defaults init)
      (cond-> (contains? init :options) (update :options #(map new-Option %)))
      (map->Field)))

(defn pb->Field
  "Protobuf to Field"
  [input]
  (cis->Field (stream/new-cis input)))

;-----------------------------------------------------------------------------
; FileOptions
;-----------------------------------------------------------------------------
(defrecord FileOptions [php-class-prefix java-generic-services java-outer-classname java-multiple-files php-generic-services php-namespace go-package optimize-for java-string-check-utf8 ruby-package java-package csharp-namespace uninterpreted-option php-metadata-namespace deprecated swift-prefix java-generate-equals-and-hash cc-enable-arenas py-generic-services cc-generic-services objc-class-prefix]
  pb/Writer

  (serialize [this os]
    (write-String 40  {:optimize true} (:php-class-prefix this) os)
    (write-Bool 17  {:optimize true} (:java-generic-services this) os)
    (write-String 8  {:optimize true} (:java-outer-classname this) os)
    (write-Bool 10  {:optimize true} (:java-multiple-files this) os)
    (write-Bool 42  {:optimize true} (:php-generic-services this) os)
    (write-String 41  {:optimize true} (:php-namespace this) os)
    (write-String 11  {:optimize true} (:go-package this) os)
    (write-FileOptions-OptimizeMode 9  {:optimize true} (:optimize-for this) os)
    (write-Bool 27  {:optimize true} (:java-string-check-utf8 this) os)
    (write-String 45  {:optimize true} (:ruby-package this) os)
    (write-String 1  {:optimize true} (:java-package this) os)
    (write-String 37  {:optimize true} (:csharp-namespace this) os)
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)
    (write-String 44  {:optimize true} (:php-metadata-namespace this) os)
    (write-Bool 23  {:optimize true} (:deprecated this) os)
    (write-String 39  {:optimize true} (:swift-prefix this) os)
    (write-Bool 20  {:optimize true} (:java-generate-equals-and-hash this) os)
    (write-Bool 31  {:optimize true} (:cc-enable-arenas this) os)
    (write-Bool 18  {:optimize true} (:py-generic-services this) os)
    (write-Bool 16  {:optimize true} (:cc-generic-services this) os)
    (write-String 36  {:optimize true} (:objc-class-prefix this) os)))

(s/def :com.google.protobuf.FileOptions/php-class-prefix string?)
(s/def :com.google.protobuf.FileOptions/java-generic-services boolean?)
(s/def :com.google.protobuf.FileOptions/java-outer-classname string?)
(s/def :com.google.protobuf.FileOptions/java-multiple-files boolean?)
(s/def :com.google.protobuf.FileOptions/php-generic-services boolean?)
(s/def :com.google.protobuf.FileOptions/php-namespace string?)
(s/def :com.google.protobuf.FileOptions/go-package string?)
(s/def :com.google.protobuf.FileOptions/optimize-for (s/or :keyword keyword? :int int?))
(s/def :com.google.protobuf.FileOptions/java-string-check-utf8 boolean?)
(s/def :com.google.protobuf.FileOptions/ruby-package string?)
(s/def :com.google.protobuf.FileOptions/java-package string?)
(s/def :com.google.protobuf.FileOptions/csharp-namespace string?)

(s/def :com.google.protobuf.FileOptions/php-metadata-namespace string?)
(s/def :com.google.protobuf.FileOptions/deprecated boolean?)
(s/def :com.google.protobuf.FileOptions/swift-prefix string?)
(s/def :com.google.protobuf.FileOptions/java-generate-equals-and-hash boolean?)
(s/def :com.google.protobuf.FileOptions/cc-enable-arenas boolean?)
(s/def :com.google.protobuf.FileOptions/py-generic-services boolean?)
(s/def :com.google.protobuf.FileOptions/cc-generic-services boolean?)
(s/def :com.google.protobuf.FileOptions/objc-class-prefix string?)
(s/def ::FileOptions-spec (s/keys :opt-un [:com.google.protobuf.FileOptions/php-class-prefix :com.google.protobuf.FileOptions/java-generic-services :com.google.protobuf.FileOptions/java-outer-classname :com.google.protobuf.FileOptions/java-multiple-files :com.google.protobuf.FileOptions/php-generic-services :com.google.protobuf.FileOptions/php-namespace :com.google.protobuf.FileOptions/go-package :com.google.protobuf.FileOptions/optimize-for :com.google.protobuf.FileOptions/java-string-check-utf8 :com.google.protobuf.FileOptions/ruby-package :com.google.protobuf.FileOptions/java-package :com.google.protobuf.FileOptions/csharp-namespace :com.google.protobuf.FileOptions/php-metadata-namespace :com.google.protobuf.FileOptions/deprecated :com.google.protobuf.FileOptions/swift-prefix :com.google.protobuf.FileOptions/java-generate-equals-and-hash :com.google.protobuf.FileOptions/cc-enable-arenas :com.google.protobuf.FileOptions/py-generic-services :com.google.protobuf.FileOptions/cc-generic-services :com.google.protobuf.FileOptions/objc-class-prefix ]))
(def FileOptions-defaults {:php-class-prefix "" :java-generic-services false :java-outer-classname "" :java-multiple-files false :php-generic-services false :php-namespace "" :go-package "" :optimize-for (FileOptions-OptimizeMode-val2label 0) :java-string-check-utf8 false :ruby-package "" :java-package "" :csharp-namespace "" :uninterpreted-option [] :php-metadata-namespace "" :deprecated false :swift-prefix "" :java-generate-equals-and-hash false :cc-enable-arenas false :py-generic-services false :cc-generic-services false :objc-class-prefix "" })

(defn cis->FileOptions
  "CodedInputStream to FileOptions"
  [is]
  (->> (tag-map FileOptions-defaults
         (fn [tag index]
             (case index
               40 [:php-class-prefix (cis->String is)]
               17 [:java-generic-services (cis->Bool is)]
               8 [:java-outer-classname (cis->String is)]
               10 [:java-multiple-files (cis->Bool is)]
               42 [:php-generic-services (cis->Bool is)]
               41 [:php-namespace (cis->String is)]
               11 [:go-package (cis->String is)]
               9 [:optimize-for (cis->FileOptions-OptimizeMode is)]
               27 [:java-string-check-utf8 (cis->Bool is)]
               45 [:ruby-package (cis->String is)]
               1 [:java-package (cis->String is)]
               37 [:csharp-namespace (cis->String is)]
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]
               44 [:php-metadata-namespace (cis->String is)]
               23 [:deprecated (cis->Bool is)]
               39 [:swift-prefix (cis->String is)]
               20 [:java-generate-equals-and-hash (cis->Bool is)]
               31 [:cc-enable-arenas (cis->Bool is)]
               18 [:py-generic-services (cis->Bool is)]
               16 [:cc-generic-services (cis->Bool is)]
               36 [:objc-class-prefix (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->FileOptions)))

(defn ecis->FileOptions
  "Embedded CodedInputStream to FileOptions"
  [is]
  (cis->embedded cis->FileOptions is))

(defn new-FileOptions
  "Creates a new instance from a map, similar to map->FileOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::FileOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::FileOptions-spec init))))]}
  (-> (merge FileOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->FileOptions)))

(defn pb->FileOptions
  "Protobuf to FileOptions"
  [input]
  (cis->FileOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; SourceCodeInfo
;-----------------------------------------------------------------------------
(defrecord SourceCodeInfo [location]
  pb/Writer

  (serialize [this os]
    (write-repeated write-embedded 1 (:location this) os)))

(s/def ::SourceCodeInfo-spec (s/keys :opt-un []))
(def SourceCodeInfo-defaults {:location [] })

(defn cis->SourceCodeInfo
  "CodedInputStream to SourceCodeInfo"
  [is]
  (->> (tag-map SourceCodeInfo-defaults
         (fn [tag index]
             (case index
               1 [:location (cis->repeated ecis->SourceCodeInfo-Location is)]

               [index (cis->undefined tag is)]))
         is)
        (map->SourceCodeInfo)))

(defn ecis->SourceCodeInfo
  "Embedded CodedInputStream to SourceCodeInfo"
  [is]
  (cis->embedded cis->SourceCodeInfo is))

(defn new-SourceCodeInfo
  "Creates a new instance from a map, similar to map->SourceCodeInfo except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SourceCodeInfo-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SourceCodeInfo-spec init))))]}
  (-> (merge SourceCodeInfo-defaults init)
      (cond-> (contains? init :location) (update :location #(map new-SourceCodeInfo-Location %)))
      (map->SourceCodeInfo)))

(defn pb->SourceCodeInfo
  "Protobuf to SourceCodeInfo"
  [input]
  (cis->SourceCodeInfo (stream/new-cis input)))

;-----------------------------------------------------------------------------
; ServiceOptions
;-----------------------------------------------------------------------------
(defrecord ServiceOptions [deprecated uninterpreted-option]
  pb/Writer

  (serialize [this os]
    (write-Bool 33  {:optimize true} (:deprecated this) os)
    (write-repeated write-embedded 999 (:uninterpreted-option this) os)))

(s/def :com.google.protobuf.ServiceOptions/deprecated boolean?)

(s/def ::ServiceOptions-spec (s/keys :opt-un [:com.google.protobuf.ServiceOptions/deprecated ]))
(def ServiceOptions-defaults {:deprecated false :uninterpreted-option [] })

(defn cis->ServiceOptions
  "CodedInputStream to ServiceOptions"
  [is]
  (->> (tag-map ServiceOptions-defaults
         (fn [tag index]
             (case index
               33 [:deprecated (cis->Bool is)]
               999 [:uninterpreted-option (cis->repeated ecis->UninterpretedOption is)]

               [index (cis->undefined tag is)]))
         is)
        (map->ServiceOptions)))

(defn ecis->ServiceOptions
  "Embedded CodedInputStream to ServiceOptions"
  [is]
  (cis->embedded cis->ServiceOptions is))

(defn new-ServiceOptions
  "Creates a new instance from a map, similar to map->ServiceOptions except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::ServiceOptions-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::ServiceOptions-spec init))))]}
  (-> (merge ServiceOptions-defaults init)
      (cond-> (contains? init :uninterpreted-option) (update :uninterpreted-option #(map new-UninterpretedOption %)))
      (map->ServiceOptions)))

(defn pb->ServiceOptions
  "Protobuf to ServiceOptions"
  [input]
  (cis->ServiceOptions (stream/new-cis input)))

;-----------------------------------------------------------------------------
; Int32Value
;-----------------------------------------------------------------------------
(defrecord Int32Value [value]
  pb/Writer

  (serialize [this os]
    (write-Int32 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.Int32Value/value int?)
(s/def ::Int32Value-spec (s/keys :opt-un [:com.google.protobuf.Int32Value/value ]))
(def Int32Value-defaults {:value 0 })

(defn cis->Int32Value
  "CodedInputStream to Int32Value"
  [is]
  (->> (tag-map Int32Value-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->Int32 is)]

               [index (cis->undefined tag is)]))
         is)
        (map->Int32Value)))

(defn ecis->Int32Value
  "Embedded CodedInputStream to Int32Value"
  [is]
  (cis->embedded cis->Int32Value is))

(defn new-Int32Value
  "Creates a new instance from a map, similar to map->Int32Value except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Int32Value-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Int32Value-spec init))))]}
  (-> (merge Int32Value-defaults init)
      (map->Int32Value)))

(defn pb->Int32Value
  "Protobuf to Int32Value"
  [input]
  (cis->Int32Value (stream/new-cis input)))

;-----------------------------------------------------------------------------
; StringValue
;-----------------------------------------------------------------------------
(defrecord StringValue [value]
  pb/Writer

  (serialize [this os]
    (write-String 1  {:optimize true} (:value this) os)))

(s/def :com.google.protobuf.StringValue/value string?)
(s/def ::StringValue-spec (s/keys :opt-un [:com.google.protobuf.StringValue/value ]))
(def StringValue-defaults {:value "" })

(defn cis->StringValue
  "CodedInputStream to StringValue"
  [is]
  (->> (tag-map StringValue-defaults
         (fn [tag index]
             (case index
               1 [:value (cis->String is)]

               [index (cis->undefined tag is)]))
         is)
        (map->StringValue)))

(defn ecis->StringValue
  "Embedded CodedInputStream to StringValue"
  [is]
  (cis->embedded cis->StringValue is))

(defn new-StringValue
  "Creates a new instance from a map, similar to map->StringValue except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StringValue-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StringValue-spec init))))]}
  (-> (merge StringValue-defaults init)
      (map->StringValue)))

(defn pb->StringValue
  "Protobuf to StringValue"
  [input]
  (cis->StringValue (stream/new-cis input)))

